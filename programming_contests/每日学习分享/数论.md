***
**加性函数**：若函数$f(x)$满足对于$\forall x,y\in \mathbb{N^{*}},\gcd(x,y)=1,f(xy)=f(x)+f(y)$则称函数$f(x)$为**加性函数**；
**完全加性函数**：若函数$f(x)$满足对于$\forall x,y\in \mathbb{N^{*}},f(xy)=f(x)+f(y)$则称函数$f(x)$为**完全加性函数**；
>注意：此处加性函数指数论上的加性函数(Additive function)，应与代数中的加性函数(Additive map)区分。

**积性函数**：若函数$f(x)$满足对于$\forall x,y\in \mathbb{N^{*}},\gcd(x,y)=1,f(xy)=f(x)f(y)$则称$f(x)$为**积性函数**；
**完全积性函数**：若函数$f(x)$满足对于$\forall x,y\in \mathbb{N^{*}},f(xy)=f(x)f(y)$则称$f(x)$为**完全积性函数**；
***
快速求素数算法：
1.朴素求单个数判断算法: $O(\sqrt{n})$
```
bool IsPrime(ll a){
    if(a==1)return 0;
    for(ll i=2;i*i<=a;++i){
        if(a%i==0){
            return 0;
        }
    }
    return 1;
}
```
没什么好说的。
2.**素数筛-埃氏筛(埃拉托斯特尼筛法)**: $O(n\log{\log n})$
```
bool vis[N];
ll prime[N];
ll Eratosthenes_sieve(ll n){
    ll i,i2,k=0;
    for(i=0;i<=N;++i)vis[i]=0;
    vis[0]=vis[1]=0;
    for(i=2;i<=n;++i){
        if(vis[i]==0){
            prime[++k]=i;
            for(i2=i;i2*i<=n;++i2)vis[i2*i]=1;
        }
    }
    return k;
}
```
通过每次将素数的倍数全部标记为已读，未标记的数就只能是素数了。
但仍有不足，有些时候可能会多次标记一个数，比如$100=2^{2}\times 5^{2}$就会被2筛一次，被5筛一次；
那么当数字较大时就会被筛很多次，从而降低了效率

3.**欧拉筛-线性筛**: $O(n)$
```
bool vis[N];
ll prime[N],k=0;
void ola_sieve(ll n){
    for(ll i=2;i<=n;++i){
        if(vis[i]==0)prime[++k]=i;
        for(ll i2=1;i*prime[i2]<=n;++i2){
            vis[prime[i2]*i]=1;
            if(i%prime[i2]==0)break;
        }
    }
}
```
**欧拉筛的核心思想就是确保每个合数只被最小质因数筛掉。或者说是被合数的最大因子筛掉。**
我们并不需要用一个for循环去筛除每一个质数的所有倍数，我们将质数存入prime数组中，然后枚举到第i个数时，就筛除所有的i*prime[i],这样在每一次循环中就刚好筛除了所有已知素数的i倍。
如果i%prime[i2]==0时，退出内层循环，为什么呢？
**因为**：
i%prime[i2]=0;  (1)
prime[i2]*k=i;  (2)
设
prime[i2+1]*i=X;   (3)
由2，3得
prime[i2]\*prime[i2+1]\*k=X;
因为: prime[i2+1]\*k>i;
设prime[i2+1]\*k=i撇
那么: i撇\*prime[i2]=X
X就会被筛去多次。
