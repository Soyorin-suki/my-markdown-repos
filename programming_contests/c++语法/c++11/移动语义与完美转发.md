# 移动语义(move semantic)和完美转发(perfect forward)
c++11重新定义了左值和右值，并允许函数通过这两种不同的类型进行重载；通过对右值的重新定义，使得该语言实现了移动语义和完美转发

## 左值、右值、左值引用与右值引用
首先先明确左值和右值的定义，c++和c采用了不同的定义方法，简单来说就是：**凡是存在于真正的内存块中的数据就是左值，其余的就是右值** 更通俗一点的说法就是**可以取地址(&)成功的就是左值，否则就是右值**
明确了左值和右值的定义后左值引用和右值引用的定义也就很明确了，**对左值的引用就是左值引用，对右值的引用就是右值引用**
一直以来我们对于“左值引用”一般是直接称为“引用”，也就是说，一般使用的`int&`其实就是左值引用，而对于右值呢？在c++11中我们使用`int&&`来表示
看接下来几个例子；
```c++
void fun(const int&i){cout<<"const int& "<<i<<endl;}
void fun(int&i){cout<<"int& "<<i<<endl;}
void fun(int&&i){cout<<"int&& "<<i<<endl;}
void fun(const int&&i){cout<<"const int&& "<<i<<endl;}
```
以往我们一般是使用第一种形式，该形式既可以绑定左值，又可以绑定右值。所以在没有后面三个重载函数的情况下我们调用语句：
```c++
int i=1;
fun(i);
fun(1);
```
他们都会输出`const int& 1`，而如果只有第二个函数则第三行语句报错，如果只有第三个函数则第二行语句报错，当四个函数同时存在时会使用对应类型最接近的函数，也就是说会输出：
```c++
int& 1
int&& 1
```
而当我们运行下面语句时：
```c++
fun([]()->const int&& {return 1;});
```
会输出`const int&& 1`


## 移动语义(move semantic)
我们来看一个例子：
```c++
class Class{
	int *element{nullptr};
	public:
	Class():element(new int[1000]{1,2,3,4}){
		cout<<"default constructor\n";
	}
	Class(const Class&c){
		cout<<"copy constructor\n";
		if(element==nullptr)element=new int[1000];
		memcopy(element,c.element,1000*sizeof(int));
	}
	~Class(){
		cout<<"destructor\n";
		delete[]element;
	}
}
```
这是一个类，考虑接下来的应用场景：
```c++
Class creatClass(){
	return Class();
}
int main(){
	Class c(creatClass());
	return 0;
}
```
这里我们的复制构造函数被调用了两次，而且这个调用并没有意义，产生的开销没有意义
这个时候我们就可以使用**移动语义** 。通过移动语义我们可以在不必要的时候避免这种情况，这个就是**移动构造函数(move constructor)**
**移动构造函数**通常具有以下形式：
```c++
Class(Class&& name)noexcept{}// noexcept可以避免发出异常，从而使编译器更加激进的优化代码
```
通过移动构造函数我们就可以避免深拷贝，节约开销
因此上面的例子我们就可以：
```c++
	Class(Class&&c)noexcept:element(c.element){
		cout<<"move constructor\n";
		c.element=null;
	}
```
之后再调用上述代码就会发现代码调用的是移动构造函数了

当我们在构造函数的时候就想使用移动构造函数时我们可以使用`std::move()`，不过如果这样的话我们就不能对参数里的类进行操作了，因为它的指针已经被置为null了

## 进一步探讨左值和右值
考虑以下代码：
```c++
void doWork(TYPE&& param){
	// opt and expression using std::move(param)
}
```
这里的`param`是右值吗？不，而是**左值**
左值和右值的区分与类型是没有关系的，而是靠能否取到地址，这里我们由于使用`move()`所以是可以对param取到地址的，所以它是一个左值，也就是说，但凡是有名字的“右值”，其实都是左值

## 完美转发(perfect forward)
我们依旧考虑一个例子：
```c++
template<typename T>// 关于为什么使用函数模版会在后文提到
void fun(T t){
	cout<<"in fun\n";
}
template<typename T>
void relay(T&& t){
	cout<<"in relay\n";
	fun(t);
}
int main(void){
	relay(Class());
	return 0;
}
```
这里我们的运行结果会发现是调用了复制构造函数：
```
default constructor
in relay
copy constructor
in func
destructor
destructor
```
而在我们的预想中这里应该调用的是移动构造函数，因为`t`是`T&&`
上文中说过，编译器认为这个值是一个左值，因为它是有名字的右值，而如果想要实现我们预想中的情况我们要如何做？
这个时候就需要使用`std::forward<T>()`,它与`move()`的区别在于`move()`会无条件的将一个参数转换成右值，而`forward<T>()`会保留参数的左右值类型（使得在转发中保持参数左右值类型不变，与原来“一模一样”）
所以我们的代码应该是这样：
```c++
template<typename T>
void relay(T&& t){
	cout<<"in relay\n";
	fun(forward<T>(t));
}
```
这样我们分别调用`relay(Class());`和`Class c();relay(c);`就分别调用的移动构造函数和复制构造函数了

## 通用引用(universal refference)
关于上面例子有一些令人疑惑的点：为什么明明参数列表中写的是`T&&`接受一个右值，却传进来的是一个左值！？
这里就有一个新的概念；**通用引用(universal refference)**

通用引用是Scott Meyers在C++ and Beyond 2012演讲中自创的一个词，用来特指一种引用的类型。构成通用引用有两个条件：
1. 必须是T&&这种形式
2. 类型T必须是通过推断得到的

所以我们完美转发的这个例子中使用的其实是通用引用
看下面代码：
```c++
template<typename T>
class Class{
	public:
	void fun(T&& t){}//这个是通用引用吗？
}
```
答案是不是，因为这个在创建时已被确定，不需要推断
所以推断只可能由以下几种可能：
1. 函数模版参数
2. auto声明
3. typedef声明
4. decltype声明

通用引用与其他引用有什么不同呢？在于**引用类型合成(Reference Collapsing Rules)**,规则；
1. T& &->T&
2. T&& &->T&
3. T& &&->T&
4. T&& &&->T&&

简单来说就是**传入的是左值引用就是左值引用，如果是右值引用就是右值引用**，但是这个合成规则**只有编译器可以使用**
这样我们就知道为什么必须要求类型由推导得出了
所以我们就建议在通用引用的情形下尽可能的使用`forward()`了，这样可以尽可能的提升性能


参考：https://blog.csdn.net/summerhust/article/details/110677472
chatGPT
