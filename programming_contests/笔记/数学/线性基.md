# 线性基
线性基是一种可以处理异或问题（通常是最大值最小值）的数据结构，设值域为$[1,N]$,就可以用一个长度为$[log_2N]$的数组来描述一个线性基，特别地，线性基第i为上的数在二进制下的最高位也是第i位
线性基具有以下性质：
1. 线性基中任意选择一些数的异或值所构成的集合，等于原序列中任意选择一些数的异或值所构成的集合。
2. 线性基是满足上述条件的最小集合。

如此我们可以推出以下几条性质：

3. 原序列中任何数，都可以由线性基中一些数异或起来得到（由性质1直接得出）
4. 线性基中不存在一组数，使得异或值变为0（违反性质2）
5. 线性基中不存在两组取值集合，使得它们的异或值相等（否则违反性质4）

现在介绍构造方法：
我们用$x_{(2)}$表示$x$的二进制表示,用$d_x$来表示线性基数组
$d_x$具有以下性质：
当$d_x$不为0时，代表这一位上存储了一个线性基
$(d_x)_(2)$的第$x$位一定为1，且从第$x+1$位往后全部为0
构造方式
```c++
void insert(ll x){
	for(ll i=30;i>=0;--i){
		if((x>>i)&&1LL){
			if(lb[i])x^=lb[i];
			else {lb[i]=x;return;}
		}
	}
}
```
我们要**尽量把$x$异或到0**，因为一旦x被异或为0，这说明x可以被线性基表示出来，就没有加入线性基的必要了
如果x的第i位是0，如果这时候异或上了d_i,它的第i位就是1且后续消不掉，因此直接跳过
如果x的第i位是1，这个时候只有异或上了d_i，才可以消掉这个1
如果这时候d_i不存在,这说明此时x不能被线性基表示出来，因此要将x加入线性基
**注意数据范围，long long的时候要用`1LL<<x`**
构造线性基的时间复杂度为$O(n\log a_i)$
当$a_i$很大的时候(例如$2^{1000}$)就不得不使用`bitset`来存储，此时的复杂度就是$O(n\frac{\log^2a_i}{w})$，w为`bitset`常数
一般不用担心线性基时间复杂度被卡


P3812 [模板]线性基
> 给定$n$个整数(数字可能重复)，求在这些数中选取任意个，使得它们的异或和最大
> $1\le n\le 50,0\le a_i\le 2^{50}$

```c++
ll n;
vector<ll>v;
void insert(ll x){
	for(ll b:v){
		x=min(x,x^b);
	}
	for(ll &b:v){
		b=min(b,b^x);
	}
	if(x)v.push_back(x);
}
void solve(void){
	cin>>n;
	for(ll i=1,tmp;i<=n;++i){
		cin>>tmp;
		insert(tmp);
	}
	ll ans=0;
	for(ll b:v){
		ans^=b;
	}
	cout<<ans<<endl;
}
```
2024ccpc网络赛J
> 形式化的讲：给定两个长度为$n$的序列$a,b$，你可以进行若干次选择一个$i(1\le i \le n)$，然后交换$a_i,b_i$，希望使得$max(f(a),f(b))$最小，其中对于一个序列$A,f(A)=\oplus_{i=1}^{n}A_i$
> 数据组数：$1\le T\le 1e5$
> $1\le n\le 1e6,0\le a_i,b_i\le 2^{31},\sum n\le 1e6$

```c++
ll n;
ll a[N],b[N],c[N];
ll lb[50];
void init(){
	for(ll i=30;i>=0;--i)lb[i]=0;
}
void insert(ll x){
	for(ll i=30;i>=0;--i){
		if((x>>i)&&1LL){
			if(lb[i])x^=lb[i];
			else {lb[i]=x;return;}
		}
	}
}
void solve(void){
	cin>>n;
	ll fa=0,fb=0;
	init();
	for(ll i=1;i<=n;++i){cin>>a[i];fa^=a[i];}
	for(ll i=1;i<=n;++i){cin>>b[i];fb^=b[i];}
	for(ll i=1;i<=n;++i){
		insert(a[i]^b[i]);
	}
	for(ll i=30;i>=0;--i){
		if((fa>>i&1LL)==0&&(fb>>i&1LL)==0)continue;
		else if((fa>>i&1LL)==1&&(fb>>i&1LL)==1){
			fa^=lb[i];fb^=lb[i];
		}else {
			if((fb>>i&1LL))swap(fa,fb);
			for(ll i2=i-1;i2>=0;--i2){
				if(fa>>i2&1LL){
					fa^=lb[i2];
					fb^=lb[i2];
				}
			}
			break;
		}
	}
	cout<<max(fa,fb)<<endl;
}
```

显然线性基不止一组，也就是说我们任意挑两个线性基出来异或可以得到一组新的线性基，换句话说，线性基具有**异或等价性**
而在所有线性基中，我们要找的是**所有$lb_x$最小的一组**
我们可以通过对线性基rebuild来得到满足以上性质的线性基：

LOJ114 第k小异或和

```c++
ll lb[100],cnt;
ll k[100];
void insert(ll x){
	for(ll i=60;i>=0;--i){
		if(!(x&(1LL<<i)))continue;
		if(lb[i])x^=lb[i];
		else {lb[i]=x;break;}
	}
}
void rebuild(){
	for(ll i=0;i<=60;++i){
		for(ll i2=i-1;i2>=0;--i2){
			if(lb[i]&(1LL<<i2))lb[i]^=lb[i2];
		}
	}
	for(ll i=0;i<=60;++i){
		if(lb[i])k[++cnt]=i;
	}
}
void solve(void){
	cin>>n;
	for(ll i=1;i<=n;++i){
		cin>>a[i];
		insert(a[i]);
	}
	rebuild();
	cin>>q;
	while(q--){
		ll x,ans=0;
		cin>>x;
		if(cnt<n)x--;//如果有0的存在
		if(x>=(1LL<<cnt)){cout<<"-1\n";continue;}
		for(ll i=1;i<=cnt;++i){
			if(x&(1LL<<(i-1)))ans^=lb[k[i]];
		}
		cout<<ans<<endl;
	}
}
```

可删除线性基
待定


参考：https://www.cnblogs.com/Troverld/p/14621434.html