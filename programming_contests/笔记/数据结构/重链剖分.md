# 重链剖分(Tree_chain_splitting)
重链剖分是将一棵树上的边转化成一条一条的链，再配合线段树等数据结构即可实现路径上的更改和查询，同时也可以用来求LCA

我们可能遇见这样一类问题：
> 给定一颗n个节点的树和m次操作，每次操作会将节点u到节点v上路径的所有点权值加上一个值或查询节点u到节点v上的所有点权值之和
> $n\le 1e5,m\le 1e5$

对于在线查询我们就需要树链剖分出场了
原理：树链剖分是根据轻重儿子，将一棵树剖分成多条链，我们就可以用数据结构维护这些链了，因为一条链上有多个节点，所以可以优化时间复杂度

我们定义以下数组：
```c++
siz[u]//以u为根的子树的结点个数
son[u]//u的重儿子的编号
top[u]//u所在链的深度最小的结点的编号
dep[u]//u的深度
faz[u]//u的父亲结点
dfn[u]//u的dfn序
rk[u]//dfn序对应的结点
```

我们将一个节点中所有的子节点中siz最大的那个子节点定义为重儿子，其余的则是轻儿子，轻儿子的top就是它本身
我们需要两个dfs去维护以上数组：
dfs1：预处理siz,son,dep,faz
```c++
void dfs1(ll fa,ll u){
	siz[u]=1;
	son[u]=0;
	for(ll v:e[u]){
		if(v==fa)continue;
		dep[v]=dep[u]+1;
		faz[v]=u;
		dfs1(u,v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}
```
dfs2：预处理top,dfn,rk
```c++
// rt表示的是当前该链上的top
void dfs2(ll u,ll rt){
	dfn[u]=++idx;
	rk[idx]=u;
	top[u]=rt;
	if(son[u])dfs2(son[u],rt);
	for(ll v:e[u]){
		if(v==faz[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
```
一条链上的结点在dfn序上也是连续的，所以我们就可以用线段树维护
```c++
void modifyOnChain(ll u,ll v,ll val){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		t.update(1,n,dfn[top[u]],dfn[u],1,val);
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	t.update(1,n,dfn[u],dfn[v],1,val);
}
```
```c++
ll queryOnChain(ll u,ll v){
	ll ret=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		ret=(ret+t.query(1,n,dfn[top[u]],dfn[u],1))%mod;
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	ret=(ret+t.query(1,n,dfn[u],dfn[v],1))%mod;
	return ret;
}
```

https://www.luogu.com.cn/problem/P3384
P3384 [模版]重链剖分
> n个结点的树，需要支持u到v的路径更新和求和，u的子树更新和求和
> $n\le 1e5,q\le 1e5$

对于路径更新求和需要用到树链剖分，子树更新求和只需要在dfn序上update和query(dfn[u],dfn[u]+siz[u]-1)即可
代码：
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+10;
const ll INF=1e11+10;
ll n,m,r,mod;
vector<ll>e[N];
ll a[N];
ll siz[N],son[N],top[N],dep[N],faz[N],dfn[N],rk[N];
ll idx;
void dfs1(ll fa,ll u){
	siz[u]=1;
	son[u]=0;
	for(ll v:e[u]){
		if(v==fa)continue;
		dep[v]=dep[u]+1;
		faz[v]=u;
		dfs1(u,v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}
void dfs2(ll u,ll rt){
	dfn[u]=++idx;
	rk[idx]=u;
	top[u]=rt;
	if(son[u])dfs2(son[u],rt);
	for(ll v:e[u]){
		if(v==faz[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
struct Segment_tree{
	ll tree[N<<2],tag[N<<2];
	inline ll ls(ll p){return p<<1;}
	inline ll rs(ll p){return (p<<1)|1;}
	void push_up(ll p){
		tree[p]=(tree[ls(p)]+tree[rs(p)])%mod;
	}
	void push_down(ll p,ll l,ll r){
		if(tag[p]){
			ll mid=l+r>>1;
			auto tmp=[&](ll p,ll l,ll r,ll k){
				tree[p]=(tree[p]+k*(r-l+1)%mod)%mod;
				tag[p]=(tag[p]+k)%mod;
			};
			tmp(ls(p),l,mid,tag[p]);
			tmp(rs(p),mid+1,r,tag[p]);
			tag[p]=0;
		}
	}
	void build(ll p,ll l,ll r){
		tag[p]=0;
		if(l==r){tree[p]=a[rk[l]]%mod;return;}
		ll mid=l+r>>1;
		build(ls(p),l,mid);
		build(rs(p),mid+1,r);
		push_up(p);
	}
	void update(ll nowl,ll nowr,ll l,ll r,ll p,ll k){
		if(l<=nowl&&nowr<=r){
			tree[p]=(tree[p]+(nowr-nowl+1)*k%mod)%mod;
			tag[p]=(tag[p]+k)%mod;
			return;
		}
		ll mid=nowl+nowr>>1;
		push_down(p,nowl,nowr);
		if(l<=mid)update(nowl,mid,l,r,ls(p),k);
		if(mid+1<=r)update(mid+1,nowr,l,r,rs(p),k);
		push_up(p);
	}
	ll query(ll nowl,ll nowr,ll l,ll r,ll p){
		if(l<=nowl&&nowr<=r){
			return tree[p];
		}
		ll mid=nowl+nowr>>1,ret=0;
		push_down(p,nowl,nowr);
		if(l<=mid)ret=(ret+query(nowl,mid,l,r,ls(p)))%mod;
		if(mid+1<=r)ret=(ret+query(mid+1,nowr,l,r,rs(p)))%mod;
		return ret;
	}
}t;
void modifyOnChain(ll u,ll v,ll val){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		t.update(1,n,dfn[top[u]],dfn[u],1,val);
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	t.update(1,n,dfn[u],dfn[v],1,val);
}
ll queryOnChain(ll u,ll v){
	ll ret=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		ret=(ret+t.query(1,n,dfn[top[u]],dfn[u],1))%mod;
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	ret=(ret+t.query(1,n,dfn[u],dfn[v],1))%mod;
	return ret;
}
ll op,x,y,z;
void solve(void){
	// freopen("P3384_4.in","r",stdin);
	// freopen("P3384_4.out2","w",stdout);
	cin>>n>>m>>r>>mod;
	for(ll i=1;i<=n;++i)cin>>a[i];
	for(ll i=1;i<n;++i){
		ll u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs1(0,r);
	dfs2(r,r);
	t.build(1,1,n);
	// for(ll i=1;i<=n;++i)
	for(ll i=1;i<=m;++i){
		cin>>op;
		if(op==1){
			cin>>x>>y>>z;
			modifyOnChain(x,y,z);
		}else if(op==2){
			cin>>x>>y;
			cout<<queryOnChain(x,y)<<endl;
		}else if(op==3){
			cin>>x>>y;
			t.update(1,n,dfn[x],dfn[x]+siz[x]-1,1,y);
		}else {
			cin>>x;
			cout<<t.query(1,n,dfn[x],dfn[x]+siz[x]-1,1)<<endl;
		}
	}
}
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	ll times=1;
	// cin>>times;
	while(times--)solve();
	return 0;
}
```

https://www.luogu.com.cn/problem/P2590
P2590 树的统计
水题,
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=2e5+10;
const ll INF=1e11+10;
ll n,q;
vector<ll>e[N];
ll a[N];
ll siz[N],faz[N],top[N],dep[N],son[N],rk[N],dfn[N],idx;
void dfs1(ll fa,ll u){
	siz[u]=1;
	son[u]=0;
	dep[u]=dep[fa]+1;
	for(ll v:e[u]){
		if(v==fa)continue;
		faz[v]=u;
		dfs1(u,v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}
void dfs2(ll u,ll rt){
	dfn[u]=++idx;
	rk[idx]=u;
	top[u]=rt;
	if(son[u])dfs2(son[u],rt);
	for(ll v:e[u]){
		if(v==faz[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
struct Segment_tree{
	ll tree1[N<<2],tree2[N<<2];
	inline ll ls(ll p){return p<<1;}
	inline ll rs(ll p){return (p<<1)|1;}
	void push_up(ll p){
		tree1[p]=tree1[ls(p)]+tree1[rs(p)];
		tree2[p]=max(tree2[ls(p)],tree2[rs(p)]);
	}
	void build(ll p,ll l,ll r){
		if(l==r){tree1[p]=tree2[p]=a[rk[l]];return;}
		ll mid=l+r>>1;
		build(ls(p),l,mid);
		build(rs(p),mid+1,r);
		push_up(p);
	}
	void update(ll nowl,ll nowr,ll l,ll r,ll p,ll k){
		if(l<=nowl&&nowr<=r){
			tree1[p]=(r-l+1)*k;
			tree2[p]=k;
			return;
		}
		ll mid=nowl+nowr>>1;
		if(l<=mid)update(nowl,mid,l,r,ls(p),k);
		if(mid+1<=r)update(mid+1,nowr,l,r,rs(p),k);
		push_up(p);
	}
	ll query1(ll nowl,ll nowr,ll l,ll r,ll p){
		if(l<=nowl&&nowr<=r){
			return tree1[p];
		}
		ll mid=nowl+nowr>>1,ret=0;
		if(l<=mid)ret+=query1(nowl,mid,l,r,ls(p));
		if(mid+1<=r)ret+=query1(mid+1,nowr,l,r,rs(p));
		return ret;
	}
	ll query2(ll nowl,ll nowr,ll l,ll r,ll p){
		if(l<=nowl&&nowr<=r){
			return tree2[p];
		}
		ll mid=nowl+nowr>>1,ret=-3e4;
		if(l<=mid)ret=max(ret,query2(nowl,mid,l,r,ls(p)));
		if(mid+1<=r)ret=max(ret,query2(mid+1,nowr,l,r,rs(p)));
		return ret;
	}
}t;
ll query1(ll u,ll v){
	ll ret=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		ret=ret+t.query1(1,n,dfn[top[u]],dfn[u],1);
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	ret=ret+t.query1(1,n,dfn[u],dfn[v],1);
	return ret;
}
ll query2(ll u,ll v){
	ll ret=-3e4;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		ret=max(ret,t.query2(1,n,dfn[top[u]],dfn[u],1));
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	ret=max(ret,t.query2(1,n,dfn[u],dfn[v],1));
	return ret;
}
void solve(void){
	cin>>n;
	for(ll i=1;i<n;++i){
		ll u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(ll i=1;i<=n;++i)cin>>a[i];
	cin>>q;
	dfs1(0,1);
	dfs2(1,1);
	t.build(1,1,n);
	while(q--){
		string s;
		ll x,y;
		cin>>s>>x>>y;
		if(s=="CHANGE"){
			t.update(1,n,dfn[x],dfn[x],1,y);
		}else if(s=="QSUM"){
			cout<<query1(x,y)<<endl;
		}else if(s=="QMAX"){
			cout<<query2(x,y)<<endl;
		}
	}
}
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	ll times=1;
	// cin>>times;
	while(times--)solve();
	return 0;
}
```
https://www.luogu.com.cn/problem/P3178
P3178
水题
https://www.luogu.com.cn/problem/P3379
P3379 [模版]最近公共祖先
利用树链剖分可以$O(\log n)$求LCA
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5e5+10;
const ll INF=1e11+10;
ll n,m,s;
vector<ll>e[N];
ll siz[N],dfn[N],dep[N],top[N],faz[N],son[N],rk[N],idx;
void dfs1(ll fa,ll u){
	siz[u]=1;
	faz[u]=fa;
	son[u]=0;
	dep[u]=dep[fa]+1;
	for(ll v:e[u]){
		if(v==fa)continue;
		dfs1(u,v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}
void dfs2(ll u,ll rt){
	dfn[u]=++idx;
	rk[idx]=u;
	top[u]=rt;
	if(son[u])dfs2(son[u],rt);
	for(ll v:e[u]){
		if(v==faz[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
ll lca(ll u,ll v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	return u;
}
void solve(void){
	cin>>n>>m>>s;
	for(ll i=1;i<n;++i){
		ll u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs1(0,s);
	dfs2(s,s);
	for(ll i=1;i<=m;++i){
		ll u,v;
		cin>>u>>v;
		cout<<lca(u,v)<<endl;
	}
}
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	ll times=1;
	// cin>>times;
	while(times--)solve();
	return 0;
}
```





参考：https://zhuanlan.zhihu.com/p/63595869