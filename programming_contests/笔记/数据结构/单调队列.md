# 单调队列(monotonic queue)
> **“如果一个选手比你小还比你强，那么你就可以退役了”**――单调队列

单调队列主要是解决一个一种类似滑动窗口类问题的数据结构，即：
在长度为$n$的序列中，求每个长度为$m$的区间的区间最值，它的时间复杂度是$O(n)$，在这个问题中比$O(n\log n)$的ST表和线段树更优且常数和空间复杂度也更优

单调队列的主要思想是，维护一个双向队列(deque)，遍历序列，仅当一个元素可能成为某个区间的最值时才保留它
e.g.
$[1.3.6.2],5,1,7$ 此时单调队列里就是$6,2$
$1.[3.6.2,5],1,7$ 此时单调队列里就是$6,5$
$1.3.[6.2,5,1],7$ 此时单调队列里就是$6,5,1$
$1.3.6.[2,5,1,7]$ 此时单调队列里就是$7$
因此可以发现这个队列总是单调递减的，因此称作单调队列（如果是维护最小值，那么队列是单调递增的）


P1440 求m区间内的最小值
> 给定一个n项的序列，求出每一项前m个数中的最小值，若前面的数不足m项则从第1个数开始，若前面没有数，则输出0
> $1\le m\le n\le 2e6,1\le a_i\le 3e7$

代码：
```c++
ll n,m;
ll a[N];
ll q[N],p[N];
ll head,tail;
void solve(void){
	cin>>n>>m;
	for(ll i=1;i<=n;++i)cin>>a[i];
	head=1;tail=0;
	for(ll i=1;i<=n;++i){
		cout<<((head<=tail)?q[head]:0)<<endl;
		while(head<=tail&&q[tail]>=a[i])tail--;
		q[++tail]=a[i];
		p[tail]=i;
		while(p[head]<=i-m)head++;
	}
}
```
或
```c++
deque<ll>q;
for(ll i=1;i<=n;++i){
	cout<<(q.empty()?0:a[q.front()])<<endl;
	while(!q.empty()&&a[q.back()]>=a[i])q.pop_back();
	q.push_back(i);
	while(q.front()<=i-m)q.pop_front();
}
```
也可用于单调队列优化dp


参考：https://zhuanlan.zhihu.com/p/346354943