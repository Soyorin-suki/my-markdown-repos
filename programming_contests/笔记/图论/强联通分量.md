# 强联通分量
在一个有向图中，如果所有点之间都可以相互到达，那么就称这个图为强联通的
强连通分量是有向图的极大的强连通子图，所谓极大，代表将图划分为几个强连通子图后，不存在两个强连通子图相互到达
常见的求强连通分量的算法包括：
1. kosaraju 时间复杂度为$O(V+E)$，实际运行中比Targan慢
2. Targan 时间复杂度为$O(V+E)$，最重要的求强连通分量的算法
3. Gabow

## kosaraju算法
kusaraju算法使用两个dfs运行
对于一个强联通分量，将其所有边都变为反边，其仍然是一个强联通分量
那么我们就可以先正向dfs一下，然后存储每个点dfs结束的时间，重复以下操作：
1. 选择完成时间最后的点，对其逆图dfs，把所有遍历的点存为一个强联通分量
2. 如果还有点未被访问到，重复1.

代码：
```c++
// SCC
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e4+10;
const ll INF=1e11+10;
ll n,m;
vector<ll>e[N];//原图
vector<ll>e2[N];//逆图
ll ct[N];//完成时间
ll vis[N],fa[N],facnt[N],scccnt;
ll out[N];
ll timest;
void dfs(ll u){
	vis[u]=1;
	for(ll v:e[u]){
		if(vis[v]!=1)dfs(v);
	}
	ct[++timest]=u;
}
void rdfs(ll u,ll k){
	vis[u]=2;
	for(ll v:e2[u]){
		if(vis[v]!=2)rdfs(v,k);
	}
	fa[u]=k;
	facnt[k]++;
}
void kosaraju(){
	for(ll i=1;i<=n;++i){
		if(vis[i]!=1)dfs(i);
	}
	for(ll i=n;i>0;--i){
		if(vis[ct[i]]!=2)rdfs(ct[i],++scccnt);
	}
}
```

P2341 受欢迎的牛
>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的――如果$A$喜欢$B$，$B$喜欢$C$，那么$A$也喜欢$C$。牛栏里共有$N$N 头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星。
>$1\le N\le 10^4,1\le M\le 5*10^4$

最后所有的受欢迎的牛一定是一个强连通分量，同时如果有两个强连通分量的出度为0就说明不存在受欢迎的牛
code:
```c++
// SCC
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e4+10;
ll n,m;
vector<ll>e[N];
vector<ll>e2[N];
ll ct[N],cnt,vis[N],fa[N],facnt[N],scccnt;
ll out[N];
ll timest;
void dfs(ll u){
	vis[u]=1;
	for(ll v:e[u]){
		if(vis[v]!=1)dfs(v);
	}
	ct[++timest]=u;
}
void rdfs(ll u,ll k){
	vis[u]=2;
	for(ll v:e2[u]){
		if(vis[v]!=2)rdfs(v,k);
	}
	fa[u]=k;
	facnt[k]++;
}
void kosaraju(){
	for(ll i=1;i<=n;++i){
		if(vis[i]!=1)dfs(i);
	}
	for(ll i=n;i>0;--i){
		if(vis[ct[i]]!=2)rdfs(ct[i],++scccnt);
	}
}
void solve(void){
	cin>>n>>m;
	for(ll i=1;i<=m;++i){
		ll u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e2[v].push_back(u);
	}
	kosaraju();
	for(ll u=1;u<=n;++u){
		for(ll v:e[u]){
			if(fa[u]==fa[v])continue;
			out[fa[u]]++;
		}
	}
	ll t=0,ans=0;
	for(ll i=1;i<=scccnt;++i){
		if(out[i]==0){
			t++;
			ans=facnt[i];
		}
	}
	if(t==1){
		cout<<ans<<endl;
	}else {
		cout<<0<<endl;
	}
}
```

## Tarjan
使用dfs搜索树
在Targan算法中使用一个栈依次将每个未搜索到的点加入栈中，并且为每个节点u维护了两个值：
1. $dfn_u$：深度优先搜索中节点u被搜索的次序
2. $low_u$：在u的子树中可以到达的已经在栈中的最早的点

一个节点的子树内节点的dfn序都大于该节点的dfn序
从根开始的一条路径上的dfn序严格递增，low严格非降

按照dfs依次搜索，维护每个节点的dfn和low，并让搜索到的结点依次入栈，考虑节点u和v有以下三种情况：
1. v未被访问：继续搜索，并使用$low_v$更新$low_u$($low_u=\min(low_u,low_v$)
2. v被访问过，并且在栈中：根据low的定义，用$dfn_v$更新$low_u$
3. v被访问过，不在栈中：说明v已经搜索完毕，其联通分量已被处理

code:
```c++
ll n,m;
vector<ll>e[N];
vector<ll>stk;
ll dfn[N],low[N],vis[N];
ll scc[N],sc,siz[N];
ll dfncnt=0;
void targan(ll u){
	low[u]=dfn[u]=++dfncnt;
	stk.push_back(u);vis[u]=1;
	for(ll v:e[u]){
		if(vis[v]==0){
			targan(v);
			low[u]=min(low[u],low[v]);
		}else if(vis[v]==1){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		++sc;
		while(stk.back()!=u){
			scc[stk.back()]=sc;
			vis[stk.back()]=2;
			siz[sc]++;
			stk.pop_back();
		}
		scc[stk.back()]=sc;
		siz[sc]++;
		vis[u]=2;
		stk.pop_back();
	}
}
```

## Garbow
