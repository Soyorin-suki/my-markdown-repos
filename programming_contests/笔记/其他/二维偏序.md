# 二维偏序(two-dimensional partial order)
二维偏序是指这样一类问题：在点对$(a_1,b_1),(a_2,b_2),(a_3,b_3),\cdots$上满足某种偏序关系$\prec$，现有$(a_i,b_i)$，求满足$(a_i,b_i)\prec (a_i,b_j)$的$(a_i,b_i)$数量
偏序在数学上是指满足自反性，反对称性和传递性的序关系
事实上，在二维的情形下，我们分别对两个属性定义序关系，一定能得到一种偏序关系：
$(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\lesseqgtr a_i\;\text{and}\; b_j\lesseqgtr b_i$
举个例子就是$a<b \&c<d\rightarrow(a,b)\prec (c,d)$

P1908 逆序对
> 算出一个大小为n的数组中所有的逆序对的个数之和
> $n\le 5e5,a_i\le 1e9$

逆序对是序列中$i\lt j$而且$a_i\gt a_j$的数对的对数
因此我们只需要用树状数组边更新边统计一下答案即可
```c++
//two-dementional partial order
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5e5+10;
const ll INF=1e11+10;
ll n,ans=0;
ll a[N],c[N];
inline ll lowbit(ll x){return x&-x;}
struct Fenwick_tree{
	ll tree[N];
	void update(ll i,ll x){
		for(;i<=n;i+=lowbit(i))tree[i]+=x;
	}
	ll query(ll i){
		ll ret=0;
		for(;i;i-=lowbit(i))ret+=tree[i];
		return ret;
	}
}t;
void solve(void){
	cin>>n;
	for(ll i=1;i<=n;++i)cin>>a[i],c[i]=a[i];
	sort(c+1,c+1+n,greater<ll>());
	ll len=unique(c+1,c+1+n)-c-1;
	for(ll i=1;i<=n;++i){
		a[i]=lower_bound(c+1,c+1+len,a[i],greater<ll>())-c;
	}
	for(ll i=1;i<=n;++i){
		t.update(a[i],1);
		ans+=t.query(a[i]-1);
	}
	cout<<ans<<endl;

}
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	ll times=1;
	// cin>>times;
	while(times--)solve();
	return 0;
}
```
P5094 [USACO04OPEN] MooFest G 加强版
> 有n头奶牛排成一列，第i头奶牛的听力是$v_i$，如果奶牛j想让奶牛i听到它说话，就需要用高达$v_i*dis(i,j)$的音量才醒，如果奶牛i和奶牛j想相互交谈就需要$\max(v_i,v_j)*dis(i,j)$的音量相互交谈，其中$dis(i,j)$表示相互之间的距离
> 现在n头奶牛站在一条直线上，对应的坐标为$x_i$，问如果每对奶牛都在相互交谈，并且使用最小音量，那么所有$N(N-1)/2$对奶牛之间谈话的音量之和为多少
> $1\le N,v_i,x_i\le 4e5$

分别使用树状数组统计$i\lt j,v_i\le v_j$和$i\lt j,v_i\gt v_j$的答案，加和即可
```c++
//two-dementional partial order
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=2e5+10;
const ll INF=1e11+10;
ll n,ans=0;
struct cow{
	ll v,x;
	cow(ll vv=0,ll xx=0):v(vv),x(xx){}
}a[N];
bool cmp1(const cow&a,const cow&b){
	if(a.x==b.x)return a.v<b.v;
	return a.x<b.x;
}
bool cmp2(const cow&a,const cow&b){
	if(a.x==b.x)return a.v<b.v;
	return a.x>b.x;
}
inline ll lowbit(ll x){return x&-x;}
struct Fenwick_tree{
	ll tree[N];
	void ini(void){
		for(ll i=1;i<N;++i)tree[i]=0;
	}
	void update(ll i,ll x){
		for(;i<N;i+=lowbit(i))tree[i]+=x;
	}
	ll query(ll i){
		ll ret=0;
		for(;i;i-=lowbit(i))ret+=tree[i];
		return ret;
	}
}x,v;
void solve(void){
	cin>>n;
	for(ll i=1;i<=n;++i)cin>>a[i].v>>a[i].x;
	sort(a+1,a+1+n,cmp1);
	ll sum=0;
	for(ll i=1;i<=n;++i){
		ans+=a[i].v*(a[i].x*v.query(a[i].v)-x.query(a[i].v));
		v.update(a[i].v,1);
		x.update(a[i].v,a[i].x);
	}
	x.ini();v.ini();
	sort(a+1,a+1+n,cmp2);
	for(ll i=1;i<=n;++i){
		ans+=a[i].v*(x.query(a[i].v-1)-a[i].x*v.query(a[i].v-1));
		v.update(a[i].v,1);
		x.update(a[i].v,a[i].x);
	}
	cout<<ans<<endl;
}
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	ll times=1;
	// cin>>times;
	while(times--)solve();
	return 0;
}
```

https://codeforces.com/problemset/problem/249/D

> 坐标系上给出$n$个点，求最多有多少个点连成折线而且斜率在$\frac{a}{b}$和$\frac{c}{d}$之间（不包括相等）
> 第一条折线必须从坐标原点开始而且坐标原点不计入答案
> $1\le n,x_i,y_i\le 1e5$

现对其进行坐标基分解可得$u_i=b*y_i-a*x_i,v_i=c*x_i-d*y_i$
然后就是求最长的$u_i\lt u_j$且$v_i\lt v_j$的长度
可以用树状数组求解，但是需要注意在排序时要**对第二关键字进行逆序排序**
否则会统计错误
```c++
//https://codeforces.com/problemset/problem/249/D
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=2e5+10;
const ll INF=1e11+10;
ll n,ans=0;
ll a,b,c,d;
pair<ll,ll>p[N];
bool cmp(pair<ll,ll> a,pair<ll,ll> b){
	if(a.first==b.first)return a.second>b.second;
	else return a.first<b.first;
}
ll tree[N];
inline ll lowbit(ll x){return x&-x;}
void update(ll i,ll x){
	for(;i<=(n<<1);i+=lowbit(i))tree[i]=max(tree[i],x);
}
ll query(ll i){
	ll ans=0;
	for(;i;i-=lowbit(i))ans=max(ans,tree[i]);
	return ans;
}
void solve(void){
	cin>>n;
	char zhanwei;
	cin>>a>>zhanwei>>b>>c>>zhanwei>>d;
	if(b*c<=a*d){
		cout<<'0'<<endl;
	}
	ll len=0;
	for(ll i=1;i<=n;++i){
		ll x,y;
		cin>>x>>y;
		p[i].first=b*y-a*x;
		p[i].second=c*x-d*y;
		if(p[i].first<=0||p[i].second<=0)continue;
		else p[++len]=p[i];
	}
	sort(p+1,p+1+len,cmp);
	vector<ll>tmp;
	for(ll i=1;i<=len;++i)tmp.push_back(p[i].second);
	sort(tmp.begin(),tmp.begin()+len);
	map<ll,ll>mp;
	for(ll i=0;i<len;++i){
		mp[tmp[i]]=i+1;
	}
	for(ll i=1;i<=len;++i){
		p[i].second=mp[p[i].second];
	}

	for(ll i=1;i<=len;++i){
		ll cur=query(p[i].second-1)+1;
		update(p[i].second,cur);
	}
	for(ll i=1;i<=len;++i)ans=max(ans,tree[i]);
	cout<<ans<<endl;
}
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	ll times=1;
	// cin>>times;
	while(times--)solve();
	return 0;
}
```

___

**偏序问题中的定义**
最简单的二维偏序$(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\le a_i\;\text{and}\; b_j\le b_i$的处理方法是选$a$为第一关键词，$b$为第二关键词进行排序；如果必要，将$b$离散化；然后按顺序把$b$一个一个推入树状数组，动态求前缀和。
而其他二维偏序关系，可以作不同的处理转化为最简单的二维偏序。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\lt a_i\;\text{and}\; ?$：把第一关键词的小于等于改成小于，需要在对第二关键词排序时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\ge a_i\;\text{and}\; ?$把第一关键词的小于等于改成大于等于，需要在对第一关键词排序时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\gt a_i\;\text{and}\; ?$把第一关键词的小于等于改成大于，需要在对两个关键词排序时都进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$：把第二关键词的小于等于改成小于，查询时使用`query(x-1)`而不是`query(x)`。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$把第二关键词的小于等于改成大于等于，对第二关键词**离散化**时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$把第二关键词的小于等于改成大于等于，对第二关键词**离散化**时进行**逆序排序**，并且查询时使用`query(x-1)`而不是`query(x)`。

参考：
https://zhuanlan.zhihu.com/p/112504092