# 离散化(discretization)
当具体的值对答案没有贡献而我们只关注值相对的大小的时候可以使用的一种预处理方法
离散化本质是一种哈希，是将对应的值映射为对应的大小排名
当一些含有难以转化为下标的数据（如小数，负数，1e9等）导致一些数据结构难以使用时，就可以考虑对数据进行离散化预处理
离散化可以使用STL简单快速的完成
例如对于一个数组A[N]，我们可以先复制一个相同的序列C[N]
```c++
ll C[N];
for(ll i=1;i<=n;++i)C[i]=A[i];
```
对其排序，然后使用unique去重：
```c++
sort(C+1,C+1+n);
ll len=unique(C+1,C+1+n)-C-1;//len为不重复元素的数量
```
之后再用一个数组L[N],储存A中每个元素的排名：
```c++
ll L[N];
for(ll i=1;i<=n;++i){
	L[i]=lower_bound(C+1,C+1+len,a[i])-C;
}
```
这样我们就实现了原序列的离散化
因为排序和n次二分查找的时间复杂度都为O(nlogn)
所以离散化的时间复杂度就是O(nlogn)
完整代码：
```c++
ll A[N],C[N],L[N];
for(ll i=1;i<=n;++i)C[i]=A[i];
sort(C+1,C+1+n);
ll len=unique(C+1,C+1+n)-C-1;
for(ll i=1;i<=n;++i){
	L[i]=lower_bound(C+1,C+1+len,a[i])-C;
}
```
如果需要从大到小离散化则只需要在sort()和lower_bound()里加上greater<ll>()即可
参考：https://zhuanlan.zhihu.com/p/112497527