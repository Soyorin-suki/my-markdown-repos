## 使用树状数组进行区间查询和区间修改
>[树状数组的区间修改与区间查询](https://blog.csdn.net/qq_37656398/article/details/128934622?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172282221616800182169317%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172282221616800182169317&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128934622-null-null.142^v100^pc_search_result_base7&utm_term=%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2&spm=1018.2226.3001.4187)
#### 1：树状数组的区间修改
不妨设$a_i$为第i个元素，那么我们可以定义差分数组$d_i=a_i-a_{i-1}$
这样$a_i=\sum^{n}_{k=1}d_k$
因此我们要进行区间修改将[l,r]加上k只需要在l处加上k，在r+1处减去k即可
因此进行单点查询就是求前缀和
#### 2：树状数组的区间查询
$\sum^{k}_ia_i=\sum^k_{i=1}\sum^i_{j=1}d_i\\=\sum^k_{i=1}d_i\times(k-i+1)\\=(k+1)\sum^k_{i=1}d_i-\sum^k_{i=1}{d_i\times i}$
因此可以用两个树状数组维护，一个维护$d_i$,一个维护$i\times d_i$，这样就可以进行两次单点查询得出1-k的前缀和
例题：[[P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)]
代码：
```c++
ll n,q;
ll a[N],b[N],t[N];
inline ll lowbit(ll x){
	return x&-x;
}
void update(ll x,ll k){
	for(ll i=x;i<=N;i+=lowbit(i)){
		a[i]+=k;b[i]+=k*x;
	}
}
inline void update(ll l,ll r,ll k){
	update(l,k);
	update(r+1,-k);
}
ll query(ll x){
	ll res=0;
	for(ll i=x;i>0;i-=lowbit(i)){
		res+=(x+1)*a[i]-b[i];
	}
	return res;
}
inline ll query(ll l,ll r){
	return query(r)-query(l-1);
}





void solve(){
	cin>>n>>q;
	for(ll i=1;i<=n;++i)cin>>t[i];
	for(ll i=1;i<=n;++i){
		update(i,t[i]-t[i-1]);
	}
	while(q--){
		ll t;
		cin>>t;
		if(t==1){
			ll x,y,k;
			cin>>x>>y>>k;
			update(x,y,k);
		}
		else {
			ll x,y;
			cin>>x>>y;
			cout<<query(x,y)<<endl;
		}
	}
```