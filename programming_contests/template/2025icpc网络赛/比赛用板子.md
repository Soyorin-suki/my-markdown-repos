

___

**快读**

```c++
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
```

___

**离散化$O(\log{n})$**

```c++
ll A[N],C[N],L[N];
// A原数组,C中间数组,L结果数组
for(ll i=1;i<=n;++i)C[i]=A[i];
sort(C+1,C+1+n);
ll len=unique(C+1,C+1+n)-C-1;
for(ll i=1;i<=n;++i){
    L[i]=lower_bound(C+1,C+1+len,A[i])-C;
}
```

___

**树状数组**

```c++
inline ll lowbit(ll x){return x&(-x);}
struct FenwickTree{
    ll tree[N],n;
    void init(ll _n){
        n=_n;
        for(ll i=0;i<=n;++i){
            tree[i]=0;
        }
    }
    void update(ll pos,ll k){
        for(ll i=pos;i<=n;i+=lowbit(i))a[i]+=k;
    }
    ll query(ll pos){
        ll res=0;
        for(ll i=pos;i>0;i-=lowbit(i))res+=a[i];
        return res;
    }
}
```

**树状数组特殊运算实现区间加和**

```c++
inline ll lowbit(ll x){
    return x&-x;
}
struct FenwickTree{
    ll a[N],b[N],n;
    void init(int _n){
        n=_n;
        for(ll i=0;i<=n;++i){
            a[i]=b[i]=0;
        }
    }
    void update(ll x,ll k){
        for(ll i=x;i<=n;i+=lowbit(i)){
            a[i]+=k;b[i]+=k*x;
        }
    }
    inline void update(ll l,ll r,ll k){
        update(l,k);
        update(r+1,-k);
    }
    ll query(ll x){
        ll res=0;
        for(ll i=x;i>0;i-=lowbit(i)){
            res+=(x+1)*a[i]-b[i];
        }
        return res;
    }
    inline ll query(ll l,ll r){
        return query(r)-query(l-1);
    }
};
```

___

**线段树**

```c++
ll n,q;
struct SegmentTree{
    ll tree[N<<2],tag[N<<2];
    inline ll ls(ll p){return p<<1LL;}
    inline ll rs(ll p){return (p<<1LL)|1LL;}
    void pushUp(ll p){
        tree[p]=tree[ls(p)]+tree[rs(p)];
    }
    void pushDown(ll p,ll l,ll r){
        ll mid=(l+r)>>1;
        tree[ls(p)]+=tag[p]*(mid-l+1);
        tree[rs(p)]+=tag[p]*(r-mid);
        tag[ls(p)]+=tag[p];
        tag[rs(p)]+=tag[p];
        tag[p]=0;
    }
    void build(ll p,ll l,ll r){
        if(l==r){tree[p]=a[l];return;}
        ll mid=(l+r)>>1;
        build(ls(p),l,mid);
        build(rs(p),mid+1,r);
        pushUp(p);
    }
    void update(ll nowl,ll nowr,ll l,ll r,ll p,ll k){
        if(l<=nowl&&nowr<=r){
            tree[p]+=k*(nowr-nowl+1);
            tag[p]+=k;
            return;
        }
        ll mid=(nowl+nowr)>>1;
        pushDown(p);
        if(l<=mid)update(nowl,mid,l,r,ls(p),k);
        if(mid+1<=r)update(mid+1,nowr,l,r,rs(p),k);
        pushUp(p);
    }
    ll query(ll nowl,ll nowr,ll l,ll r,ll p){
        if(l<=nowl&&nowr<=r){
            return tree[p];
        }
        ll mid=(nowl+nowr)>>1,ret=0;
        pushDown(p);
        if(l<=mid)ret+=query(nowl,mid,l,r,ls(p));
        if(mid+1<=r)ret+=query(mid+1,nowr,l,r,rs(p));
        return ret;
    }
}t;
```

___

**主席树**
来自P3919

```c++
ll n,m;
ll a[N];
struct node{
    int sum=0;
    int l=0,r=0;
}tr[N*32];
ll root[N];
ll cnt;
ll build(ll l,ll r){
    ll now=++cnt;
    if(l==r){tr[now].sum=a[l];return now;}
    ll mid=(l+r)>>1;
    tr[now].l=build(l,mid);
    tr[now].r=build(mid+1,r);
    return now;
}
ll update(ll pre,ll l,ll r,ll p,ll v){
    ll now=++cnt;
    tr[now]=tr[pre];
    if(l==r){
        tr[now].sum=v;
        return now;
    }
    ll mid=(l+r)>>1;
    if(p<=mid)tr[now].l=update(tr[pre].l,l,mid,p,v);
    if(mid+1<=p)tr[now].r=update(tr[pre].r,mid+1,r,p,v);
    return now;
}
ll query(ll now,ll l,ll r,ll p){
    if(l==r)return tr[now].sum;
    ll mid=(l+r)>>1;
    if(p<=mid)return query(tr[now].l,l,mid,p);
    if(mid+1<=p)return query(tr[now].r,mid+1,r,p);
}
void solve(void){
    cin>>n>>m;
    for(ll i=1;i<=n;++i)cin>>a[i];
    root[0]=build(1,n);
    for(ll i=1;i<=m;++i){
        ll ver,op,p,val;
        cin>>ver>>op>>p;
        if(op==1){
            cin>>val;
            root[i]=update(root[ver],1,n,p,val);
        }else if(op==2){
            root[i]=root[ver];
            cout<<query(root[ver],1,n,p)<<endl;
        }
    }
}
```

___

**树状数组套树状数组**

```c++
const ll N=2048+10;
const ll INF=1e11+10;
const ll MOD=1e9+7;
ll n,m;
struct BIT{
    ll tr[N][N];
    ll n,m;
    void init(ll _n,ll _m){
        n=_n;m=_m;
    }
    inline ll lowbit(ll x){return x&(-x);}
    void update(ll p1,ll p2,ll k){
        for(ll i=p1;i<=n;i+=lowbit(i)){
            for(ll i2=p2;i2<=m;i2+=lowbit(i2)){
                tr[i][i2]+=k;
            }
        }
    }
    ll query(ll p1,ll p2){
        ll ret=0;
        for(ll i=p1;i>0;i-=lowbit(i)){
            for(ll i2=p2;i2>0;i2-=lowbit(i2)){
                ret+=tr[i][i2];
            }
        }
        return ret;
    }
};
struct BIT2{
    BIT bit[4];
    ll n,m;
    void init(ll _n,ll _m){
        n=_n,m=_m;
        bit[0].init(n,m),bit[1].init(n,m);
        bit[2].init(n,m),bit[3].init(n,m);
    }
    void update(ll p1,ll p2,ll k){
        bit[0].update(p1,p2,k);
        bit[1].update(p1,p2,k*p1);
        bit[2].update(p1,p2,k*p2);
        bit[3].update(p1,p2,k*p1*p2);
    }
    void update(ll l1,ll r1,ll l2,ll r2,ll k){
        update(l1,r1,k);
        update(l1,r2+1,-k);
        update(l2+1,r1,-k);
        update(l2+1,r2+1,k);
    }
    ll query(ll p1,ll p2){
        ll ret=0;
        ret+=bit[0].query(p1,p2)*(p1+1)*(p2+1);
        ret-=bit[1].query(p1,p2)*(p2+1);
        ret-=bit[2].query(p1,p2)*(p1+1);
        ret+=bit[3].query(p1,p2);
        return ret;
    }
    ll query(ll l1,ll r1,ll l2,ll r2){
        return query(l2,r2)-query(l1-1,r2)-query(l2,r1-1)+query(l1-1,r1-1);
    }
}bit2;
char ch;
void solve(void){
    cin>>ch>>n>>m;
    bit2.init(n,m);
    ll x1,y1,x2,y2,k;
    while(cin>>ch){
        cin>>x1>>y1>>x2>>y2;
        if(ch=='L'){
            cin>>k;
            bit2.update(x1,y1,x2,y2,k);
        }else{
            ll ans=bit2.query(x1,y1,x2,y2);
            cout<<ans<<endl;
        }
    }
}
```

___

**树套树**
来自P3380树套树模版题

> 五种操作
> 1.查询 k 在区间内的排名；
> 2.查询区间内排名为 k 的值；
> 3.修改某一位置上的数值；
> 4.查询 k 在区间内的前驱（前驱定义为严格小于 x，且最大的数，若不存在输出 -2147483647）；
> 5.查询 k 在区间内的后继（后继定义为严格大于 x，且最小的数，若不存在输出 2147483647）。
> 对于一组元素，一个数的排名被定义为严格比它小的元素个数加一，而排名为 k 的数被定义为“将元素从小到大排序后排在第 k 位的元素值”。

```c++
const ll N=5e4+10;
const ll INF=1e11+10;
const ll MOD=1e9+7;
const ll MAXV=1e8+10;
int n,m;
int a[N];
struct BITsegmentTree{
    struct NODE{
        int lson,rson,val;
    }tr[N*20*20];
    int root[N],cnt;
    inline int lowbit(int x){return x&(-x);}
    void push_up(int rt){
        int now=0;
        if(tr[rt].lson)now+=tr[tr[rt].lson].val;
        if(tr[rt].rson)now+=tr[tr[rt].rson].val;
        tr[rt].val=now;
    }
    void update(int&rt,int nowl,int nowr,int p,int k){
        if(rt==0)rt=++cnt;
        if(nowl==nowr){
            tr[rt].val+=k;
            return;
        }
        ll mid=(nowl+nowr)>>1;
        if(p<=mid)update(tr[rt].lson,nowl,mid,p,k);
        else update(tr[rt].rson,mid+1,nowr,p,k);
        push_up(rt);
    }
    void BITupdate(int ver,int p,int k){
        for(int i=ver;i<=n;i+=lowbit(i)){
            // update(root[i],0,MAXV,a[p],-1);
            update(root[i],0,MAXV,p,k);
        }
        // a[p]=k;
    }
    int query1(vector<int> last,vector<int> now,int nowl,int nowr,int l,int r){
        int ret=0;
        if(l<=nowl&&nowr<=r){
            for(int i=0;i<now.size();++i){
                ret+=tr[now[i]].val;
            }
            for(int i=0;i<last.size();++i){
                ret-=tr[last[i]].val;
            }
            return ret;
        }
        int mid=(nowl+nowr)>>1;
        if(l<=mid){
            vector<int>lastlson,nowlson;
            for(int i=0;i<last.size();++i){
                if(tr[last[i]].lson!=0)lastlson.push_back(tr[last[i]].lson);
                // tr[lastlson[i]].lson=++cnt;
            }
            for(int i=0;i<now.size();++i){
                if(tr[now[i]].lson!=0)nowlson.push_back(tr[now[i]].lson);
                // tr[nowlson[i]].lson=++cnt;
            }
            ret+=query1(lastlson,nowlson,nowl,mid,l,r);
        }
        if(mid+1<=r){
            vector<int>lastrson,nowrson;
            for(int i=0;i<last.size();++i){
                if(tr[last[i]].rson!=0)lastrson.push_back(tr[last[i]].rson);
                // tr[lastrson[i]].rson=++cnt;
            }
            for(int i=0;i<now.size();++i){
                if(tr[now[i]].rson!=0)nowrson.push_back(tr[now[i]].rson);
                // tr[nowrson[i]].rson=++cnt;
            }
            ret+=query1(lastrson,nowrson,mid+1,nowr,l,r);
        }
        return ret;
    }
    int BITquery1(int l,int r,int vl,int vr){
        vector<int>last,now;
        for(int i=l-1;i>0;i-=lowbit(i)){
            last.push_back(root[i]);
        }
        for(int i=r;i>0;i-=lowbit(i)){
            now.push_back(root[i]);
        }
        int ans=query1(last,now,0,MAXV,vl,vr);
        return ans;
    }
    int query2(vector<int> last,vector<int> now,int nowl,int nowr,int k){
        int x=0;
        if(nowl==nowr)return nowl;
        for(int i=0;i<now.size();++i){
            x+=tr[tr[now[i]].lson].val;
        }
        for(int i=0;i<last.size();++i){
            x-=tr[tr[last[i]].lson].val;
        }
        int mid=(nowl+nowr)>>1;
        if(x>=k){
            vector<int>lastlson,nowlson;
            for(int i=0;i<last.size();++i){
                if(tr[last[i]].lson!=0)lastlson.push_back(tr[last[i]].lson);
                // tr[lastlson[i]].lson=++cnt;
            }
            for(int i=0;i<now.size();++i){
                if(tr[now[i]].lson!=0)nowlson.push_back(tr[now[i]].lson);
                // tr[nowlson[i]].lson=++cnt;
            }
            return query2(lastlson,nowlson,nowl,mid,k);
        }else{
            vector<int>lastrson,nowrson;
            for(int i=0;i<last.size();++i){
                if(tr[last[i]].rson!=0)lastrson.push_back(tr[last[i]].rson);
                // tr[lastrson[i]].rson=++cnt;
            }
            for(int i=0;i<now.size();++i){
                if(tr[now[i]].rson!=0)nowrson.push_back(tr[now[i]].rson);
                // tr[nowrson[i]].rson=++cnt;
            }
            return query2(lastrson,nowrson,mid+1,nowr,k-x);
        }
    }
    int BITquery2(int l,int r,int k){
        vector<int>last,now;
        for(int i=l-1;i>0;i-=lowbit(i)){
            last.push_back(root[i]);
        }
        for(int i=r;i>0;i-=lowbit(i)){
            now.push_back(root[i]);
        }
        int ans=query2(last,now,0,MAXV,k);
        return ans;
    }
    int BITquery4(int l,int r,int k){
        int rk=BITquery1(l,r,0,k-1);
        if(rk==0)return -2147483647;
        return BITquery2(l,r,rk);
    }

    int BITquery5(int l,int r,int k){
        int rk=BITquery1(l,r,0,k);
        if(rk==r-l+1)return 2147483647;
        return BITquery2(l,r,rk+1);
    }
}bitSegmentTree;
void solve(void){
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        bitSegmentTree.BITupdate(i,a[i],1);
    }
    while(m--){
        int opt,l,r,k;
        int ans;
        cin>>opt;
        if(opt==1){
            cin>>l>>r>>k;
            ans=bitSegmentTree.BITquery1(l,r,0,k-1)+1;
            cout<<ans<<endl;
        }else if(opt==2){
            cin>>l>>r>>k;
            ans=bitSegmentTree.BITquery2(l,r,k);
            cout<<ans<<endl;
        }else if(opt==3){
            cin>>l>>k;
            bitSegmentTree.BITupdate(l,a[l],-1);
            bitSegmentTree.BITupdate(l,k,1);
            a[l]=k;

        }else if(opt==4){
            cin>>l>>r>>k;
            ans=bitSegmentTree.BITquery4(l,r,k);
            cout<<ans<<endl;
        }else if(opt==5){
            cin>>l>>r>>k;
            ans=bitSegmentTree.BITquery5(l,r,k);
            cout<<ans<<endl;
        }
    }
}
```

___

**吉司机线段树**
主要是维护最值和第二最值
来自P6242

> 给出一个长度为 n 的数列 A，同时定义一个辅助数组 B，B 开始与 A 完全相同。接下来进行了 m 次操作，操作有五种类型，按以下格式给出：
> 1 l r k：对于所有的 i∈[l,r]，将 A_i加上 k（k 可以为负数）。
> 2 l r v：对于所有的 i∈[l,r]，将 A_i变成 min(A_i,v)。
> 3 l r：求 \sum_{i=l}^{r}A_i。
> 4 l r：对于所有的 i∈[l,r]，求 A_i的最大值。
> 5 l r：对于所有的 i∈[l,r]，求 B_i的最大值。
> 在每一次操作后，我们都进行一次更新，让 B_i=max(B_i,A_i)。

```c++
struct SegmentTreeBeats{
    struct NODE{
        ll sum;
        int maxa,maxacnt;
        int se,maxb;
        int add1,add2,add3,add4;
    }tr[N<<2];
    inline int ls(int p){return p<<1;}
    inline int rs(int p){return p<<1|1;}
    void push_up(int p){
        tr[p].sum=tr[ls(p)].sum+tr[rs(p)].sum;
        tr[p].maxa=max(tr[ls(p)].maxa,tr[rs(p)].maxa);
        tr[p].maxb=max(tr[ls(p)].maxb,tr[rs(p)].maxb);
        if(tr[ls(p)].maxa==tr[rs(p)].maxa){
            tr[p].se=max(tr[ls(p)].se,tr[rs(p)].se);
            tr[p].maxacnt=tr[ls(p)].maxacnt+tr[rs(p)].maxacnt;
        }else if(tr[ls(p)].maxa>tr[rs(p)].maxa){
            tr[p].se=max(tr[ls(p)].se,tr[rs(p)].maxa);
            tr[p].maxacnt=tr[ls(p)].maxacnt;
        }else {
            tr[p].se=max(tr[ls(p)].maxa,tr[rs(p)].se);
            tr[p].maxacnt=tr[rs(p)].maxacnt;
        }
    }
    void change(int p,int l,int r,int k1,int k2,int k3,int k4){
        tr[p].sum+=(ll)k1*tr[p].maxacnt+(ll)k2*(r-l+1-tr[p].maxacnt);
        tr[p].maxb=max(tr[p].maxb,tr[p].maxa+k3);
        tr[p].maxa+=k1;
        if(tr[p].se!=-INF)tr[p].se+=k2;
        tr[p].add3=max(tr[p].add3,tr[p].add1+k3);
        tr[p].add4=max(tr[p].add4,tr[p].add2+k4);
        tr[p].add1+=k1;tr[p].add2+=k2;
    }
    void push_down(int p,int l,int r){
        int maxn=max(tr[ls(p)].maxa,tr[rs(p)].maxa);
        int mid=(l+r)>>1;
        if(tr[ls(p)].maxa==maxn){
            change(ls(p),l,mid,tr[p].add1,tr[p].add2,tr[p].add3,tr[p].add4);
        }else {
            change(ls(p),l,mid,tr[p].add2,tr[p].add2,tr[p].add4,tr[p].add4);
        }
        if(tr[rs(p)].maxa==maxn){
            change(rs(p),mid+1,r,tr[p].add1,tr[p].add2,tr[p].add3,tr[p].add4);
        }else {
            change(rs(p),mid+1,r,tr[p].add2,tr[p].add2,tr[p].add4,tr[p].add4);
        }
        tr[p].add1=tr[p].add2=tr[p].add3=tr[p].add4=0;
    }
    void build(int p,int l,int r){
        if(l==r){
            tr[p].sum=tr[p].maxa=tr[p].maxb=a[l];
            tr[p].se=-INF;
            tr[p].maxacnt=1;
            tr[p].add1=tr[p].add2=tr[p].add3=tr[p].add4=0;
            return;
        }
        int mid=(l+r)>>1;
        build(ls(p),l,mid);
        build(rs(p),mid+1,r);
        push_up(p);
    }
    ll querySum(int p,int nowl,int nowr,int l,int r){
        if(l<=nowl&&nowr<=r){
            return tr[p].sum;
        }
        int mid=(nowl+nowr)>>1;
        ll ans=0;
        push_down(p,nowl,nowr);
        if(l<=mid)ans+=querySum(ls(p),nowl,mid,l,r);
        if(mid<r)ans+=querySum(rs(p),mid+1,nowr,l,r);
        return ans;
    }
    int queryMaxA(int p,int nowl,int nowr,int l,int r){
        if(l<=nowl&&nowr<=r){
            return tr[p].maxa;
        }
        int mid=(nowl+nowr)>>1,ans=-INF;
        push_down(p,nowl,nowr);
        if(l<=mid)ans=max(ans,queryMaxA(ls(p),nowl,mid,l,r));
        if(mid<r)ans=max(ans,queryMaxA(rs(p),mid+1,nowr,l,r));
        return ans;
    }
    int queryMaxB(int p,int nowl,int nowr,int l,int r){
        if(l<=nowl&&nowr<=r){
            return tr[p].maxb;
        }
        int mid=(nowl+nowr)>>1,ans=-INF;
        push_down(p,nowl,nowr);
        if(l<=mid)ans=max(ans,queryMaxB(ls(p),nowl,mid,l,r));
        if(mid<r)ans=max(ans,queryMaxB(rs(p),mid+1,nowr,l,r));
        return ans;
    }
    void updateAdd(int p,int nowl,int nowr,int l,int r,int k){
        if(l<=nowl&&nowr<=r){
            tr[p].sum+=k*(nowr-nowl+1);
            tr[p].maxa+=k;
            tr[p].maxb=max(tr[p].maxb,tr[p].maxa);
            if(tr[p].se!=-INF)tr[p].se+=k;
            tr[p].add1+=k;tr[p].add2+=k;
            tr[p].add3=max(tr[p].add3,tr[p].add1);
            tr[p].add4=max(tr[p].add4,tr[p].add2);
            return;
        }
        int mid=(nowl+nowr)>>1;
        push_down(p,nowl,nowr);
        if(l<=mid)updateAdd(ls(p),nowl,mid,l,r,k);
        if(mid<r)updateAdd(rs(p),mid+1,nowr,l,r,k);
        push_up(p);
    }
    void updateMin(int p,int nowl,int nowr,int l,int r,int k){
        if(k>=tr[p].maxa)return;
        if(l<=nowl&&nowr<=r&&tr[p].se<k){
            int tmp=tr[p].maxa-k;
            tr[p].sum-=(ll)tmp*tr[p].maxacnt;
            tr[p].maxa=k;
            tr[p].add1-=tmp;
            return;
        }
        int mid=(nowl+nowr)>>1;
        push_down(p,nowl,nowr);
        if(l<=mid)updateMin(ls(p),nowl,mid,l,r,k);
        if(mid<r)updateMin(rs(p),mid+1,nowr,l,r,k);
        push_up(p);
    }
}t;
void solve(void){
    cin>>n>>m;
    for(ll i=1;i<=n;++i){
        cin>>a[i];
    }
    t.build(1,1,n);
    while(m--){
        int op,l,r,k;
        cin>>op>>l>>r;
        if(op==1){
            cin>>k;
            t.updateAdd(1,1,n,l,r,k);
        }else if(op==2){
            cin>>k;
            t.updateMin(1,1,n,l,r,k);
        }else if(op==3){
            ll ans=t.querySum(1,1,n,l,r);
            cout<<ans<<endl;
        }else if(op==4){
            ll ans=t.queryMaxA(1,1,n,l,r);
            cout<<ans<<endl;
        }else if(op==5){
            ll ans=t.queryMaxB(1,1,n,l,r);
            cout<<ans<<endl;
        }
    }
}
```

___

**st表 O(1)求区间最小值**

```c++
ll a[N],n,m;
struct StTable{
    ll P=18;
    ll lg[N];
    ll st[N][20];
    void init(ll *a){
        lg[1]=0;
        for(ll i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
        for(ll i=1;i<=n;++i)st[i][0]=a[i];
        for(ll i=1;(1LL<<i)<=n;++i){
            for(ll i2=1;i2+(1LL<<i)-1<=n;++i2){
                st[i2][i]=min(st[i2][i-1],st[i2+(1LL<<(i-1))][i-1]);
            }
        }
    }
    ll query(ll l,ll r){
        // ll k=lg[r-l+1];
        ll k=lg[r-l+1];
        return min(st[l][k],st[r-(1LL<<k)+1][k]);
    }
}st;
void solve(){
    cin>>n>>m;
    for(ll i=1;i<=n;++i)cin>>a[i];
    st.init(a);
    while(m--){
        ll l,r;
        cin>>l>>r;
        cout<<st.query(l,r)<<' ';
    }
    cout<<endl;
}
```

___

**单调栈**
可以$O(n)$地扫出来第$i$个元素后面的比$a_i$大的第一个元素的下标

```c++
stack<ll>stk;
for(ll i=n;i>0;--i){
    while(!stk.empty()&&a[stk.top()]<=a[i])stk.pop();
    NGE[i]=stk.empty()?0:stk.top();
    stk.push(i);
}
```

___

**单调队列**
可以$O(n)$的扫出一个长度为n的序列中的所有区间长度为m的区间内的最值
下列每次扫出第i个元素的前m个元素的最小值，如果不够m个从第一个开始，如果前面没有就输出0

```c++
deque<ll>q;
for(ll i=1;i<=n;++i){
    cout<<(q.empty()?0:a[q.front()])<<endl;
    while(!q.empty()&&a[q.back()]>=a[i])q.pop_back();
    q.push_back(i);
    while(q.front()<=i-m)q.pop_front();
}
```

___

**堆**
常用STL: `priority_queue`实现

```c++
struct heap{
    vector<ll>ele;
    ll n=0;
    ll f=0;//0->大根堆,1->小根堆
    heap():ele(1){}
    bool cmp(ll a,ll b){
        if(f==1)return a<b;
        else return a>b;
    }
    void up(ll x){
        while(x>1&&cmp(ele[x],ele[x>>1])){
            swap(ele[x],ele[x>>1]);
            x>>=1;
        }
    }
    void down(ll x){
        while(x*2<=n){
            ll t=x*2;
            if(t+1<=n&&cmp(ele[t+1],ele[t]))t++;
            if(!cmp(ele[t],ele[x]))break;
            swap(ele[x],ele[t]);
            x=t;
        }
    }
    void push(ll x){
        ele.push_back(x);
        n++;
        up(n);
    }
    ll top(void){
        return ele[1];
    }
    void pop(void){
        swap(ele[1],ele[n]);
        n--;
        ele.pop_back();
        down(1);
    }
};
```

___

**对顶堆**
来自2024icpc第一场G的动态维护前$[\frac{n}{2}+1]$大元素（中位数）

```c++
priority_queue<ll,vector<ll>,greater<ll>>q1;//小根堆
priority_queue<ll,vector<ll>>q2;//大根堆
for(ll i=1;i<=n;++i){
    if(i&1LL){
        q2.push(a[i]);
        q1.push(q2.top());
        q2.pop();
    }else {
        q1.push(a[i]);
        q2.push(q1.top());
        q1.pop();
    }
    if(i&1LL){
        cout<<q1.top()<<endl;
    }
}
```

来自2023南京K的抄的中位数可删板子

```c++
struct medium_solver{
    private:
    multiset<ll>A,B;
    ll SA,SB;
    public:
    //初始化
    void init(void){
        A.clear();B.clear();
        SA=SB=0;
    }
    //插入一个数x
    void insert(ll x){
        if(B.empty()){
            B.insert(x);SB+=x;return;
        }
        ll mid=*B.begin();
        if(x>=mid){
            B.insert(x);SB+=x;
            if(A.size()<B.size()-1){
                auto it=B.begin();SB-=*it,SA+=*it;
                A.insert(*it);B.erase(it);
            }
        }else {
            A.insert(x);SA+=x;
            if(A.size()>B.size()){
                auto it=(--A.end());SA-=*it,SB+=*it;
                B.insert(*it);A.erase(it);
            }
        }
    }
    //删除一个数x
    void remove(ll x){
        ll mid=*B.begin();
        if(x>=mid){
            B.erase(B.find(x));SB-=x;
            if(A.size()>B.size()){
                auto it=(--A.end());SA-=*it,SB+=*it;
                B.insert(*it);A.erase(it);
            }
        }
        else {
            A.erase(A.find(x));SA-=x;
            if(A.size()<B.size()-1){
                auto it=B.begin();SB-=*it,SA+=*it;
                A.insert(*it);B.erase(it);
            }
        }
    }
    //计算题中的某个值
    ll calc(void){
        ll mid=*B.begin();
        return (mid*A.size()-SA)+(SB-mid*B.size());
    }
}s;
```

___

**按秩合并并查集**

```c++
struct DSU{
    ll fa[N],Rank[N];
    void ini(ll x){
        for(ll i=1;i<=x;++i)fa[i]=i,Rank[i]=1;
    }
    ll find(ll x){
        return (x==fa[x])?x:find(fa[x]);
    }
    void merge(ll a,ll b){
        ll u=find(a),v=find(b);
        if(u==v)return;
        if(Rank[u]<Rank[v]){
            fa[u]=v;
        }else {
            fa[v]=u;
            if(Rank[u]==Rank[v])Rank[u]++;
        }
    }
};
```

___

**Trie**

```c++
struct Trie{
    struct node{
        ll nxt[26];
    }trie[N];
    ll vis[N];
    ll tot;
    ll n,m;
    void insert(string&s,ll id){
        ll now=0;
        for(ll i=0;i<s.length();++i){
            ll ch=s[i]-'a';
            if(!trie[now].nxt[ch]){
                trie[now].nxt[ch]=++tot;
            }
            now=trie[now].nxt[ch];
        }
        vis[now]=id;
    }
    ll search(string&s){
        ll now=0;
        for(ll i=0;i<s.length();++i){
            ll ch=s[i]-'a';
            if(!trie[now].nxt[ch]){
                return 0;
            }
            now=trie[now].nxt[ch];
        }
        if(vis[now])return vis[now];
        else return 0;
    }
}trie;
```

___

**链式向前星**

```c++
struct EDGE{
    ll to,nxt,val;
}edge[M*2];
ll head[N],cnt;
void add(ll u,ll v,ll w){
    edge[++cnt].to=v;
    edge[cnt].nxt=head[u];
    edge[cnt].val=w;
    head[u]=cnt;
}
```

___

**krusktal求最小生成树**
如果tot\=\=n-1则有最小生成树且为sum
每次取不会成环的最小边直到遍历所有点 

```c++
vector<pll>e[N];
ll n,m,q,tot;
struct DSU{
    ll fa[N],n;
    void ini(int _n){
        n=_n;
        for(ll i=0;i<=n;++i)fa[i]=i;
    }
    ll find(ll x){
        return x==fa[x]?x:fa[x]=find(fa[x]);
    }
    void merge(ll x,ll y){
        ll u=find(x),v=find(y);
        fa[u]=v;
    }
}dsu;
ll kruskal(){
    ll sum=0;
    tot=0;
    dsu.ini(n);
    vector<tuple<ll,ll,ll>>vec;
    for(ll u=1;u<=n;++u){
        for(auto [v,w]:e[u]){
            vec.push_back({w,u,v});
        }
    }
    sort(vec.begin(),vec.end());
    for(auto [w,u,v]:vec){
        if(dsu.find(u)!=dsu.find(v)){
            tot++;
            sum+=w;
            dsu.merge(u,v);
        }
    }
    return sum;
}
```

___

**prim求最小生成树**
若tot\=\=n则有最小生成树为sum
从点开始加最小边直到遍历所有点

```c++
vector<pll>e[N];
ll n,m,q,dis[N],tot,vis[N];
ll prim(){
    tot=0;
    ll sum=0;
    for(ll i=1;i<=n;++i){
        dis[i]=INF;
        vis[i]=0;
    }
    dis[1]=0;
    priority_queue<pll,vector<pll>,
    greater<pll>>q;
    q.push({0,1});
    while(!q.empty()){
        auto [val,u]=q.top();
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        tot++;
        sum+=val;
        for(auto [v,w]:e[u]){
            if(w<dis[v]){
                dis[v]=w;
                q.push({dis[v],v});
            }
        }
    }
    return sum;
}
```

___

**最短路算法**
**Floyd求多远最短路O(n^3)**

```c++
vector<pll>e[N];
ll dist[N][N];
void Floyd(){
    for(ll i=1;i<=n;++i)
        for(ll i2=1;i2<=n;++i2)
            dist[i][i2]=INF;
    for(ll u=1;u<=n;++u){
        dist[u][u]=0;
        for(auto [v,w]:e[u]){
            dist[u][v]=min(dist[u][v],w);
        }
    }
    for (ll k=1;k<=n;k++) {
        for (ll u=1;u<=n;u++) {
            if(dist[u][k]==INF)continue;
            for (ll v=1;v<=n;v++) {
                if(dist[k][v]==INF)continue;
                dist[u][v]=
                min(dist[u][v],dist[u][k]+dist[k][v]);
            }
        }
    }
}
```

如果想存储路径，则使用path数组，path数组存储的是最近路径，例如：

```c++
/*
a->b->c->d
path[a][d]=b;
path[b][d]=c;
path[c][d]=d;
*/
//修改
void floyd(){
//path数组初始化为-1
    for(ll u=1;u<=n;++u){
        dist[u][u]=0;
        for(auto [v,w]:e[u]){
            if(dist[u][v]<w){
                dist[u][v]=w;
                path[u][v]=v;
            }
        }
    }
    for (ll k=1;k<=n;k++) {
        for (ll u=1;u<=n;u++) {
            if(dist[u][k]==INF)continue;
            for (ll v=1;v<=n;v++) {
                if(dist[k][v]==INF)continue;
                if(dist[u][v]>dist[u][k]+dist[k][v]){
                    dist[u][v]=
                    dist[u][k]+dist[k][v];
                    path[u][v]=path[u][k]; 
                }
            }
        }
    }
}
vector<ll>getPath(ll u,ll v){
    vector<ll>res;
    if(path[u][v]==-1)return res;
    res.push_back(u);
    while(u!=v){
        u=path[u][v];
        res.push_back(u);
    }
    return res;
}
```

___

**dijkstra算法O(nlogn)单源最短路**

```c++
ll dist[N],pre[N];
bool vis[N];
void dijkstra(ll start,ll end){
    for(ll i=1;i<=n;++i){
        dist[i]=INF;
        vis[i]=0;
        pre[i]=-1;
    }
    pre[start]=0;
    priority_queue<pll,vector<pll>,greater<pll>>q;
    dist[start]=0;
    q.push({0,start});
    while(!q.empty()){
        auto [d,u]=q.top();
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto [v,w]:e[u]){
            if(dist[u]+w<dist[v]){
                dist[v]=dist[u]+w;
                q.push({dist[v],v});
                pre[v]=u;
            }
        }
    }
}
```

___

**SPFA求单源最短路（可判断负权环）O(nlogn)** 

1. 将除源点之外的所有的点当前距离初始化为无穷，并标记为未入队。源点的当前距离为0，将源点入队。

2. 取出队首u，遍历u的所有出边，检查是否能更新所连接的点v的当前距离。如果v的当前距离被更新并且v不在队中，则将v入队。重复该操作直到队列为空。

3. 检查是否存在负权环的方法为：记录一个点的入队次数，如果超过V-1次说明存在负权环，因为最短路径上除自身外至多V-1个点，故一个点不可能被更新超过V-1次。
   
   ```c++
   ll dist[N],inque[N],cnt[N];
   ll spfa(ll start){
    queue<ll>q;
    for(ll i=1;i<=n;++i){
        dist[i]=INF;
        cnt[i]=0;
        inque[i]=0;
    }
    dist[start]=0;
    inque[start]=1;
    q.push(start);
    while(!q.empty()){
        ll u=q.front();
        q.pop();
        inque[u]=0;
        for(auto [v,w]:e[u]){
            if(dist[v]>dist[u]+w){
                dist[v]=dist[u]+w;
                if(!inque[v]){
                    q.push(v);
                    inque[v]=1;
                    cnt[v]++;
                    if(cnt[v]>n-1)return 0;
                    //负环检测
                }
            }
        }
    }
    return 1//无负环
   }
   ```

___

**Jhonson算法O(n^2logn)求多源最短路**

> 相当于先用SPFA判断负权环，然后用n次dijkstra
> 使用势函数h(x), 然后将w(u,v)转化为h(u)-h(v)

```c++
ll n, m;
vector<pll> e[N], tmpE[N]; // e 存原图，tmpE 存重标权图
ll dist[N][N], h[N], times[N], tmpDist[N];
bool vis[N];

bool spfa(ll start) {
    for (ll i = 1; i <= n; ++i) {
        h[i] = INF;
        vis[i] = 0;
        times[i] = 0;
    }
    queue<ll> q;
    h[start] = 0;
    vis[start] = 1;
    q.push(start);
    while (!q.empty()) {
        ll u = q.front();
        q.pop();
        vis[u] = 0;
        for (auto [v, w] : e[u]) {
            if (h[u] + w < h[v]) {
                h[v] = h[u] + w;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = 1;
                    times[v]++;
                    if (times[v] > n) return 0; // 负权环
                }
            }
        }
    }
    return 1;
}
void dijkstra(ll start) {
    for (ll i = 1; i <= n; ++i) {
        tmpDist[i] = INF;
        vis[i] = 0;
    }
    priority_queue<pll, vector<pll>, greater<pll>> q;
    tmpDist[start] = 0;
    q.push({0, start});
    while (!q.empty()) {
        auto [d, u] = q.top();
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto [v, w] : tmpE[u]) {
            if (tmpDist[u] + w < tmpDist[v]) {
                tmpDist[v] = tmpDist[u] + w;
                q.push({tmpDist[v], v});
            }
        }
    }
    for (ll v = 1; v <= n; ++v) {
        if (tmpDist[v] < INF) {
            dist[start][v] = tmpDist[v] + h[v] - h[start]; // 恢复原始距离
        } else {
            dist[start][v] = INF;
        }
    }
}
bool johnson() {
    // 建超级源点 0，连向所有点权值 0
    for (ll i = 1; i <= n; ++i) {
        e[0].push_back({i, 0});
    }
    if (!spfa(0)) return 0; // 存在负权环

    // 建 tmpE（重标权后的图）
    for (ll u = 1; u <= n; ++u) {
        tmpE[u].clear();
        for (auto [v, w] : e[u]) {
            ll newW = w + h[u] - h[v];
            tmpE[u].push_back({v, newW});
        }
    }

    // 每个点跑 Dijkstra
    for (ll s = 1; s <= n; ++s) {
        dijkstra(s);
    }
    return 1;
}

```

___

**Targan求强联通分量**
使用dfs搜索树
在Targan算法中使用一个栈依次将每个未搜索到的点加入栈中，并且为每个节点u维护了两个值：

1. $dfn_u$：深度优先搜索中节点u被搜索的次序

2. $low_u$：在u的子树中可以到达的已经在栈中的最早的点
```c++
ll n,m;
vector<ll>e[N];
struct SCC{
    ll dfn[N],low[N],inStk[N],dfnCnt;
    vector<ll>stk;
    vector<ll>sccV[N];
    vector<ll>sccE[N];
    ll vInScc[N];
    ll sccCnt;
    void tarjan(ll u){
        low[u]=dfn[u]=++dfnCnt;
        stk.push_back(u);inStk[u]=1;
        for(ll v:e[u]){
            if(!dfn[v]){
                targan(v);
                low[u]=min(low[u],low[v]);
            }else if(inStk[v]){
                low[u]=min(low[u],dfn[v]);
            }
        }
        if(dfn[u]==low[u]){
            ++sccCnt;
            while(stk.back()!=u){
                vInScc[stk.back()]=sccCnt;
                inStk[stk.back()]=0;
                sccV[sccCnt].push_back(stk.back());
                stk.pop_back();
            }
            vInScc[u]=sccCnt;
            inStk[u]=0;
            sccV[sccCnt].push_back(u);
            stk.pop_back();
        }
    }
    void prework(){
        for(ll i=1;i<=n;++i){
            dfn[i]=low[i]=inStk[i]=vInScc[i]=0;
            sccV[i].clear();sccE[i].clear();
        }
        dfnCnt=sccCnt=0;stk.clear();
        for(ll u=1;u<=n;++u){
            if(!dfn[u])tarjan(u);
        }
        vector<ll>vis(n+1,0);
        for(ll i=1;i<=sccCnt;++i){
            for(ll u:sccV[i]){
                for(ll v:e[u]){
                    ll tmp=vInScc[v];
                    if(tmp==i)continue;
                    if(vis[tmp]!=i){
                        sccE[i].push_back(tmp);
                        vis[tmp]=i;
                    }
                }
            }
        }
    }
}scc;

```
___
**边双联通分量**
```c++
struct EBCC{
    int low[N],dfn[N],dfnCnt;
    int vInEbcc[N];
    vector<pii>bridge;
    vector<vector<int>>ebcc;
    vector<int>stk;
    void tarjan(int lst,int u){
        low[u]=dfn[u]=++dfnCnt;
        stk.push_back(u);
        for(auto [v,id]:e[u]){
            if(id==(lst^1))continue;
            if(!dfn[v]){
                tarjan(id,v);
                low[u]=min(low[u],low[v]);
                if(low[v]>dfn[u]){
                    bridge.push_back({u,v});
                }
            }else {
                low[u]=min(low[u],dfn[v]);
            }
        }
        if(low[u]==dfn[u]){
            vector<int>vec;
            vec.push_back(u);
            while(stk.back()!=u){
                vec.push_back(stk.back());
                vInEbcc[stk.back()]=ebcc.size();
                stk.pop_back();
            }
            vInEbcc[u]=ebcc.size();
            stk.pop_back();
            ebcc.push_back(vec);
        }
    }
    //计算P2860的答案
    int solve(){
        vector<int>deg(n+1,0);
        ebcc.push_back(vector<int>());
        for(int i=1;i<=n;++i){
            if(!dfn[i])tarjan(0,i);
        }
        for(auto [u,v]:bridge){
            deg[vInEbcc[u]]++;
            deg[vInEbcc[v]]++;
        }
        int ans1=0,ans2=0;
        for(int i=1;i<ebcc.size();++i){
            if(deg[i]==0)ans1++;
            else if(deg[i]==1)ans2++;
        }
        if(ebcc.size()==2)return 0;
        return ans1+(ans2+1)/2;
    }
}ebcc;
void solve(void){
    cin>>n>>m;
    for(int i=1;i<=m;++i){
        int u,v;
        cin>>u>>v;
        //特殊的存边方式
        e[u].push_back({v,i*2});
        e[v].push_back({u,i*2+1});
    }
    int ans=ebcc.solve();
    cout<<ans<<endl;
}
```

___

**点双联通分量**

```c++
struct VBCC{
    int dfn[N],low[N],dfncnt;
    vector<int>vbccV[N];
    vector<int>stk;
    int vc;
    int isCut[N];
    void tarjan(int fa,int u){
        low[u]=dfn[u]=++dfncnt;
        int children=0;
        stk.push_back(u);
        for(int v:e[u]){
            if(!dfn[v]){
                children++;
                tarjan(u,v);
                low[u]=min(low[u],low[v]);
                if(low[v]>=dfn[u]){
                    if(fa!=-1)isCut[u]=1;
                    ++vc;
                    while(!stk.empty()){
                        int x=stk.back();
                        stk.pop_back();
                        vbccV[vc].push_back(x);
                        if(x==v)break;
                    }
                    vbccV[vc].push_back(u);
                }
            }else if(v!=fa){
                low[u]=min(low[u],dfn[v]);
            }
        }
        if(fa==-1&&children>=2)isCut[u]=1;
    }
    void solve(){
        vc=0;
        for(int i=1;i<=n;++i){
            if(!dfn[i]){
                tarjan(-1,i);
                if(e[i].size()==0){
                    vbccV[++vc].push_back(i);
                }
            }
            int f=e[i].size();
            for(int v:e[i]){
                if(v!=i)f=0;
            }
            if(f){
                vbccV[++vc].push_back(i);
            }
        }
    }
}vbcc;
void solve(void){
    cin>>n>>m;
    for(int i=1;i<=m;++i){
        int u,v;
        cin>>u>>v;
        e[u].push_back(v);
        if(u!=v)e[v].push_back(u);//防止自环
    }
    vbcc.solve();
    cout<<vbcc.vc<<endl;
    for(int i=1;i<=vbcc.vc;++i){
        cout<<vbcc.vbccV[i].size()<<" ";
        for(int u:vbcc.vbccV[i]){
            cout<<u<<' ';
        }
        cout<<endl;
    }
}
```

___

**2-SAT**

```c++
int n,m;
vector<int>e[N];
int isSolved;
int ans[N];
struct SCC{
    int low[N],dfn[N],dfnCnt;
    vector<int>stk;
    int inStk[N],vInScc[N];
    vector<vector<int>>sccV;
    void tarjan(int u){
        low[u]=dfn[u]=++dfnCnt;
        stk.push_back(u);
        inStk[u]=1;
        for(int v:e[u]){
            if(!dfn[v]){
                tarjan(v);
                low[u]=min(low[u],low[v]);
            }else if(inStk[v])low[u]=min(low[u],dfn[v]);
        }
        if(low[u]==dfn[u]){
            vector<int>vec;
            while(stk.back()!=u){
                vec.push_back(stk.back());
                inStk[stk.back()]=0;
                vInScc[stk.back()]=sccV.size();
                stk.pop_back();
            }
            vec.push_back(u);
            inStk[u]=0;
            vInScc[u]=sccV.size();
            stk.pop_back();
            sccV.push_back(vec);
        }
    }
    void prework(){
        sccV.push_back(vector<int>());
        for(int i=1;i<=2*n;++i){
            if(!dfn[i])tarjan(i);
        }
    }
    void solve(){
        prework();
        isSolved=0;
        for(int i=1;i<=n;++i){
            if(vInScc[i]==vInScc[i+n]){
                return;
            }else if(vInScc[i]<vInScc[i+n]){
                ans[i]=0;
            }else ans[i]=1;
        }
        isSolved=1;
    }
}scc;
void solve(void){
    cin>>n>>m;
    for(int i=1;i<=m;++i){
        int x,y,b1,b2;
        cin>>x>>b1>>y>>b2;
        e[x+(1-b1)*n].push_back(y+b2*n);
        e[y+(1-b2)*n].push_back(x+b1*n);
    }
    scc.solve();
    if(isSolved==1){
        cout<<"POSSIBLE\n";
        for(int i=1;i<=n;++i){
            cout<<ans[i]<<' ';
        }
        cout<<endl;
    }else{
        cout<<"IMPOSSIBLE\n";
    }
}
```

___

**欧拉路径**
这里是字典序最小的欧拉路径

```c++
ll n,m;
vector<ll>e[N];
ll start[N];
ll inde[N],outde[N];
vector<ll>ans;
void dfs(ll u){
    for(ll i=start[u];i<e[u].size();i=start[u]){
        start[u]=i+1;
        dfs(e[u][i]);
    }
    ans.push_back(u);
}
void solve(void){
    cin>>n>>m;
    for(ll i=1;i<=m;++i){
        ll u,v;
        cin>>u>>v;
        e[u].push_back(v);
        inde[v]++;
        outde[u]++;
    }
    //字典序最小
    for(ll i=1;i<=n;++i){
        sort(e[i].begin(),e[i].end());
    }
    ll cntin=0,cntout=0;
    for(ll i=1;i<=n;++i){
        if(inde[i]>outde[i]+1||outde[i]>inde[i]+1){
            cout<<"No\n";
            return;
        }
        if(inde[i]==outde[i]+1)cntin++;
        else if(inde[i]+1==outde[i])cntout++;
    }
    //如果是欧拉回路，cntin==0 && cntout==0。
    //如果是欧拉路径，cntin==1 && cntout==1。
    if(cntin!=cntout||(cntin!=0&&cntin!=1)){
        cout<<"No\n";
    }
    if(cntin==0&&cntout==0){
        dfs(1);
    }else for(ll i=1;i<=n;++i){
        if(outde[i]==inde[i]+1){
            dfs(i);
            break;
        }
    }
    while(!ans.empty()){
        cout<<ans.back()<<" ";
        ans.pop_back();
    }
    cout<<endl;
}
```

___

**重链剖分**

```c++
siz[u]//以u为根的子树的结点个数
son[u]//u的重儿子的编号
top[u]//u所在链的深度最小的结点的编号
dep[u]//u的深度
faz[u]//u的父亲结点
dfn[u]//u的dfn序
rk[u]//dfn序对应的结点
```

```c++
vector<vector<ll>>e;
struct HLD {
    ll n, idx;
    ll siz[N], son[N], top[N], dep[N], faz[N], dfn[N], rk[N];
    void init(int _n){
        n=_n;idx=0;
        for(int i=1;i<=n;++i){
            siz[i]=son[i]=top[i]=dep[i]=faz[i]=dfn[i]=rk[i]=0;
        }
    }
    void dfs1(ll fa,ll u){
        siz[u]=1; son[u]=0;
        for(ll v:e[u]){
            if(v==fa) continue;
            dep[v]=dep[u]+1;
            faz[v]=u;
            dfs1(u,v);
            siz[u]+=siz[v];
            if(siz[v]>siz[son[u]]) son[u]=v;
        }
    }
    void dfs2(ll u,ll rt){
        dfn[u]=++idx; rk[idx]=u; top[u]=rt;
        if(son[u]) dfs2(son[u],rt);
        for(ll v:e[u]){
            if(v==faz[u]||v==son[u]) continue;
            dfs2(v,v);
        }
    }
    void build(ll rt=1){
        dep[rt]=1; faz[rt]=0;
        dfs1(0,rt);
        dfs2(rt,rt);
    }
    void modifyOnChain(ll u,ll v,ll val,SegmentTree &t,ll mod){
        while(top[u]!=top[v]){
            if(dep[top[u]]<dep[top[v]]) swap(u,v);
            t.update(1,n,dfn[top[u]],dfn[u],1,val);
            u=faz[top[u]];
        }
        if(dep[u]>dep[v]) swap(u,v);
        t.update(1,n,dfn[u],dfn[v],1,val);
    }
    ll queryOnChain(ll u,ll v,SegmentTree &t,ll mod){
        ll ret=0;
        while(top[u]!=top[v]){
            if(dep[top[u]]<dep[top[v]]) swap(u,v);
            ret=(ret+t.query(1,n,dfn[top[u]],dfn[u],1))%mod;
            u=faz[top[u]];
        }
        if(dep[u]>dep[v]) swap(u,v);
        ret=(ret+t.query(1,n,dfn[u],dfn[v],1))%mod;
        return ret;
    }
    ll lca(ll u,ll v){
        while(top[u]!=top[v]){
            if(dep[top[u]]<dep[top[v]]) swap(u,v);
            u=faz[top[u]];
        }
        if(dep[u]>dep[v]) swap(u,v);
        return u;
    }
}hld;
```

___

**dfn序求LCA**

> O(nlogn)预处理O(1)查询

```c++
ll n,m,s;
struct EDGE{
    ll to,nxt;
}e[N<<1];
ll cnt=0,head[N],lg[N];
void add(ll u,ll v){
    e[++cnt].to=v;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
ll dn,dfn[N],mi[20][N];
inline ll get(ll u,ll v){
    return dfn[u]<dfn[v]?u:v;
}
void dfs(ll f,ll u){
    mi[0][dfn[u]=++dn]=f;
    for(ll i=head[u];i;i=e[i].nxt){
        if(e[i].to!=f)dfs(u,e[i].to);
    }
}
ll LCA(ll u,ll v){
    if(u==v)return u;
    u=dfn[u],v=dfn[v];
    if(u>v)swap(u,v);
    ll d=lg[v-u];
    return get(mi[d][u+1],mi[d][v-(1<<d)+1]);
}
void solve(){
    cin>>n>>m>>s;
    for(ll i=2;i<=n;++i){
        ll u,v;
        cin>>u>>v;add(u,v);add(v,u);
    }
    lg[1]=0;
    for(ll i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
    dfs(0,s);
    for(ll i=1;i<=lg[n];++i){
        for(ll i2=1;i2+(1<<i)-1<=n;++i2){
            mi[i][i2]=get(mi[i-1][i2],mi[i-1][i2+(1<<i-1)]);
        }
    }
    while(m--){
        ll u,v;
        cin>>u>>v;
        cout<<LCA(u,v)<<endl;
    }
}
```

___

**[模版]最长公共子序列**

> 两个n排列

```c++
vector<ll>a(n+1),b(n+1),c(n+1);
map<ll,ll>mp;
for(i=1;i<=n;++i)cin>>a[i],mp[a[i]]=i;
for(i=1;i<=n;++i)cin>>b[i],c[i]=2e5+10;
c[0]=0;
for(i=1;i<=n;++i){
ll l=0,r=ans,mid;
if(mp[b[i]]>c[ans])c[++ans]=mp[b[i]];
else {
/* ll temp=lower_bound(c.begin()+1,c.begin()+ans+1,mp[b[i]],
[&](ll value,ll element)->bool {
return value<mp[element];})-c.begin();
c[temp]=min(c[temp],mp[b[i]]);*/
while(l<r){
    mid=(l+r)>>1;
    if(c[mid]>mp[b[i]])r=mid;
    else l=mid+1;
}
c[l]=min(mp[b[i]],c[l]);
}
}
cout<<ans<<endl;
```

___

**拓扑排序O(n+m)**

> 若需要以字典序排序则只需要将队列换成优先队列即可

```c++
int inde[N],ts[N];//inde[N]表示入度，ts[N]表示拓扑排序的结果。
void toposort(){
    queue<ll>q;
    for(ll i=1;i<=n;++i){
        if(inde[i]==0){
            q.push(i);
        }
    }
    while(!q.empty()){
        ll u=q.front();
        q.pop();
        for(ll i=head[u];i;i=edge[i].next){
            ll v=edge[i].to;
            inde[v]--;
            if(inde[v]==0)q.push(v);
        }
    }
}
```

___

**线性基**

```c++
struct LinearBasis{
    vector<ll>v;//从低位到高位的基底
    ll f0;//是否能够构造出0
    void init(){
        v.assign(61,0);
        f0=0;
    }
    void insert(ll x){
        for(ll i=60;i>=0;--i){
            if((x>>i)&1){
                if(!v[i]){v[i]=x;return;}
                x^=v[i];
            }
        }
        f0=1;
    }
    //构造最大值
    ll getmax(){
        ll ans=0;
        for(ll i=60;i>=0;--i){
            if((ans^v[i])>ans)ans^=v[i];
        }
        return ans;
    }
    //构造最小值
    ll getmin(){
        if(f0)return 0;
        for(ll i=0;i<=60;++i){
            if(v[i]!=0)return v[i];
        }
        return -1;//占位符
    }
    void prework(){
        for(ll i=1;i<=60;++i){
            for(ll i2=0;i2<i;++i2){
                if(v[i]&(1LL<<(i2)))v[i]^=v[i2];
            }
        }
    }
    //询问第k大
    ll getkth(ll k){
        if(k==1&&f0)return 0;
        if(f0)k--;
        prework();
        ll ans=0;
        for(ll i=0;i<=60;++i){
            if(v[i]){
                if(k&1)ans^=v[i];
                k>>=1;
            }
        }
        return ans;
    }
    //询问存在性
    ll check(ll x){
        for(ll i=60;i>=0;--i){
            if((x>>i)&1){
                if(!v[i])return 0;
                x^=v[i];
            }
        }
        return 1;
    }
}lb;
//线性基求并，将线性基b中的所有元素插入线性基a中，插不进去忽略
```

线性基求交, 时间关系暂时抄的板子

```c++
struct node {
    ll p[60];
    node() {memset(p,0,sizeof p);}
};
node d,all;
node merge(const node&a,const node&b) {
    node res;
    d=a,all=a; //all表示目前所有可用的低位基 
    ll k; //k是把Bi和它的低位削减至0所用到的A的异或和 
    for(int i=0;i<60;++i) {
        if(!b.p[i]) continue;
        ll v=b.p[i];
        k=0;
        int j;
        for(j=i;j>=0;--j)
            if(1LL<<j&v) {
                if(all.p[j]>0)
                    v^=all.p[j],k^=d.p[j];
                else break;
            }
        if(!v) res.p[i]=k;
        else all.p[j]=v,d.p[j]=k;
    }
    return res;
}
```

___

**自适应辛普森积分**

```c++
const double eps=1e-7;
double l,r,a,b,c,d;
double f(double x){
    return (c*x+d)/(a*x+b);
}
double simpson(double l,double r){
    double mid=(l+r)/2.0;
    return (r-l)*(f(l)+4*f(mid)+f(r))/6.0;
}
double asr(double l,double r,double eps,double ans,ll step){
    double mid=(l+r)/2;
    double fl=simpson(l,mid),fr=simpson(mid,r);
    if(abs(fl+fr-ans)<=15*eps&&step<0){
        return fl+fr+(fl+fr-ans)/15;
    }
    return asr(l,mid,eps/2,fl,step-1)+asr(mid,r,eps/2,fr,step-1);
}
void solve(void){
    cin>>a>>b>>c>>d>>l>>r;
    cout.setf(ios::fixed);
    cout<<setprecision(6)<<asr(l,r,eps,0,10)<<endl;
}
```

```c++
const double eps=1e-6;
double a;
double f(double x){
    return pow(x,a/x-x);
}
double simpson(double l,double r){
    double mid=(l+r)/2;
    return (r-l)*(f(l)+4*f(mid)+f(r))/6;
}
double asr(double l,double r,double eps,double ans,ll step){
    double mid=(l+r)/2;
    double fl=simpson(l,mid),fr=simpson(mid,r);
    if(abs(fl+fr-ans)<=15*eps&&step<0){
        return fl+fr+(fl+fr-ans)/15;
    }
    return asr(l,mid,eps/2,fl,step-1)+asr(mid,r,eps/2,fr,step-1);
}
void solve(void){
    cin>>a;
    if(a<0){
        cout<<"orz\n";
        return;
    }
    double ans=0,tmp=0;
    cout.setf(ios::fixed);
    cout<<setprecision(5)<<asr(1e-7,100,eps,0,10)<<endl;

}
```

___

**拉格朗日插值（不实用版）**
$O(n^2)$实现：

```c++
// 朴素拉格朗日插值O(n2)
ll n,k;
ll x[N],y[N],a[N];
ll q_pow(ll base,ll p){
    ll ret=1;
    while(p){
        if(p&1LL)ret=ret*base%MOD;
        base=base*base%MOD;
        p>>=1;
    }
    return ret;
}
inline ll inv(ll x){
    return q_pow(x,MOD-2);
}
void solve(void){
    cin>>n>>k;
    for(ll i=1;i<=n;++i){
        cin>>x[i]>>y[i];
    }
    ll ans=0;
    for(ll i=1;i<=n;++i){
        ll tmp=y[i];
        for(ll i2=1;i2<=n;++i2){
            if(i==i2)continue;
            tmp=(tmp*inv((x[i]-x[i2]+MOD)%MOD))%MOD;
        }
        for(ll i2=1;i2<=n;++i2){
            if(i==i2)continue;
            tmp=(tmp*((k-x[i2]+MOD)%MOD))%MOD;
        }
        ans=(tmp+ans)%MOD;
    }
    cout<<ans<<endl;
}
```

当横坐标是连续整数时的拉格朗日插值
时间复杂度$O(n\log n)$

```c++
ll n,k,cnt=0;
ll y[N],fact[N];
ll pl[N],pr[N];
ll q_pow(ll base,ll p){
    ll ret=1;
    while(p){
        if(p&1LL)ret=ret*base%MOD;
        base=base*base%MOD;
        p>>=1;
    }
    return ret;
}
inline ll inv(ll x){
    return q_pow(x,MOD-2);
}
void ini(ll n){
    fact[0]=fact[1]=1;
    for(ll i=2;i<=n;++i)fact[i]=fact[i-1]*i%MOD;
    for(ll i=1;i<=n;++i)y[i]=(y[i-1]+q_pow(i,k))%MOD;
}
void solve(void){
    cin>>n>>k;
    cnt=k+2;
    ini(cnt);
    ll ans=0;
    if(k+2>=n){
        cout<<y[n]<<endl;
        return;
    }
    pl[0]=1LL;
    pl[1]=(n-1+MOD)%MOD;
    pr[cnt+1]=1LL;
    for(ll i=2;i<=cnt;++i)pl[i]=pl[i-1]*((n-i+MOD)%MOD)%MOD;
    for(ll i=cnt;i>0;--i)pr[i]=pr[i+1]*((n-i+MOD)%MOD)%MOD;
    for(ll i=1;i<=cnt;++i){
        ll tmp=y[i];
        tmp=tmp*pl[i-1]%MOD*pr[i+1]%MOD;
        tmp=tmp*inv(fact[i-1]*fact[cnt-i]%MOD)%MOD;
        if((cnt-i)&1LL)tmp=(MOD-tmp);
        ans=(ans+tmp)%MOD;
    }
    cout<<ans<<endl;
}
```

___

**数论分块**
用$O(sqrt(n))$求出$\sum_{i=l}^{r}f(i)*[\frac{n}{i}]$;

```c++
for(int l = 1, r; l <= n; l = r + 1) {
    r = n / (n / l);
    ans += (r - l + 1) * (n / l)
}
```

___

**线性求逆元（不会）**

```c++
inv[1] = 1;
for (int i = 2; i <= n; ++i) {
inv[i] = (long long)(p - p / i) * inv[p % i] % p;
}
```

___

**拓展欧几里得求逆元（不会）**

```c++
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    ll ans=exgcd(b,a%b,x,y);
    ll temp=x;
    x=y;
    y=temp-a/b*y;
    return ans;
}
ll inv(ll a,ll p)
{
    ll x,y;
    ll g=exgcd(a,p,x,y);
    if(g!=1) return -1;//不互质则无解
    else return (x%p+p)%p;
}
```

___

**CRT**
GPT生成

```c++
struct CRT {
    // 解: x ≡ a[i] (mod m[i])，要求 m[i] 两两互质
    // 返回 (x, M)，其中 x 是最小非负解，M = lcm(所有 m[i]) = ∏m[i]
    // 如果无解返回 (-1, -1)

    ll exgcd(ll a,ll b,ll &x,ll &y){
        if(!b){x=1,y=0;return a;}
        ll x1,y1;
        ll g=exgcd(b,a%b,x1,y1);
        x=y1;
        y=x1-(a/b)*y1;
        return g;
    }

    pair<ll,ll> solve(const vector<ll>& a,const vector<ll>& m){
        ll n=a.size();
        ll x=0, M=1; // 当前解 x ≡ a0 (mod m0)，M = m0
        for(ll i=0;i<n;++i){
            ll a2=a[i], m2=m[i];
            ll k1,k2;
            ll g=exgcd(M,m2,k1,k2);
            if((a2-x)%g!=0)return {-1,-1}; // 无解
            ll mod=m2/g;
            ll t=((a2-x)/g%mod+mod)%mod*k1%mod;
            x=x+t*M;
            M=M/g*m2;
            x=(x%M+M)%M; // 保证非负
        }
        return {x,M};
    }
} crt;
int main(){
    vector<ll>a={2,3,2};
    vector<ll>m={3,5,7}; // x ≡ 2(mod 3), x ≡ 3(mod 5), x ≡ 2(mod 7)
    auto ans=crt.solve(a,m);
    cout<<ans.first<<" "<<ans.second<<endl; // 23 105
}

```

___

**素数筛-埃氏筛(埃拉托斯特尼筛法)O(nloglogn)**

```c++
bool vis[N];
ll prime[N];
ll Eratosthenes_sieve(ll n){
    ll i,i2,k=0;
    for(i=0;i<=N;++i)vis[i]=0;
    vis[0]=vis[1]=0;
    for(i=2;i<=n;++i){
        if(vis[i]==0){
            prime[++k]=i;
            for(i2=i;i2*i<=n;++i2)vis[i2*i]=1;
        }
    }
    return k;
}
```

___

**欧拉筛-线性筛O(n)**

```c++
bool vis[N];
ll prime[N],k=0;
void ola_sieve(ll n){
    for(ll i=2;i<=n;++i){
        if(vis[i]==0)prime[++k]=i;
        for(ll i2=1;i*prime[i2]<=n;++i2){
            vis[prime[i2]*i]=1;
            if(i%prime[i2]==0)break;
        }
    }
}
```

**可求欧拉函数**

```c++
ll phi[N],phi_sum[N];
ll vis[N];
ll prime[N],cnt=0;
void e_phi(ll x){
    vis[0]=vis[1]=1;
    phi[1]=1;cnt=0;
    for(ll i=2;i<=x;++i)vis[i]=0;
    for(ll i=2;i<=x;++i){
        if(!vis[i])prime[++cnt]=i,phi[i]=i-1;
        for(ll i2=1;i2<=cnt&&i*prime[i2]<=x;++i2){
            vis[prime[i2]*i]=1;
            if(i%prime[i2]==0){
                phi[i*prime[i2]]=phi[i]*prime[i2];
                break;
            }
            else phi[i*prime[i2]]=phi[i]*(prime[i2]-1);
        }
    }
    for(ll i=1;i<=x;++i)phi_sum[i]=phi_sum[i-1]+phi[i];
}
```

___

**线性筛求莫比乌斯函数**

```c++
void getMu() {
mu[1] = 1;
for (int i = 2; i <= n; ++i) {
    if (!flg[i]) p[++tot] = i, mu[i] = -1;
    for (int j = 1; j <= tot && i * p[j] <= n; ++j) {
    flg[i * p[j]] = 1;
    if (i % p[j] == 0) {
        mu[i * p[j]] = 0;
        break;
    }
    mu[i * p[j]] = -mu[i];
    }
}
}
```

___

**miller-rabin算法O(logn)求是否为质数**

```c++
inline ll Abs(ll x){
    return x<0?-x:x;
}
ll q_pow(ll base,ll p,ll mod){
    ll ret=1LL;
    while(p){
        if(p&1LL)ret=(lll)ret*(lll)base%mod;
        base=(lll)base*(lll)base%mod;
        p>>=1;
    }
    return ret;
}
ll gcd(ll a,ll b){
    ll r=1;
    while(r){
        r=a%b;
        a=b;
        b=r;
    }
    return a;
}

mt19937 rd(time(NULL)*(time(NULL)+114514));
const ll test_prime[]={2,3,5,7,11,13,17,19,23,29,31,37};
bool mr(ll base,ll n){
    if(q_pow(base,n-1,n)!=1)return 0;
    ll u=n-1,t=0;
    while(!(u&1LL)){
        u>>=1;
        ll tmp=q_pow(base,u,n);
        if(tmp!=1&&tmp!=n-1)return 0;
        if(tmp==n-1)return 1;
    }
    return 1;
}
inline bool is_prime(ll n){
    if(n>40){
        for(ll test:test_prime)
            if(!mr(test,n))return 0;
        return 1;
    }
    for(ll test:test_prime){
        if(n==test)return 1;
    }
    return 0;
}
```

___

**Prho算法$O(n^{\frac{1}{4}})$分解质因数**

```c++
ll rho(ll n){
    ll s=0,t=0,c=1LL*rd()%(n-1)+1;
    ll stp=0,goal=1;
    ll val=1;
    for(goal=1;;goal<<=1,s=t,val=1){
        for(stp=1;stp<=goal;++stp){
            t=f(t,c,n);
            val=(lll)val*Abs(s-t)%n;
            if((stp%127)==0){
                ll d=gcd(val,n);
                if(d>1)return d;
            }
        }
        ll d=gcd(val,n);
        if(d>1)return d;
    }
}
ll fact[256],tot=0;
void prho(ll x){
    if(x<2)return;
    if(is_prime(x)){
        fact[++tot]=x;
        return ;
    }
    ll pi=rho(x);
    while(pi>=x)pi=rho(x);
    // while(x%pi==0){x/=pi;}
    prho(pi);
    prho(x/pi);
}
ll p[128],cnt[128],ccnt=0;
```

___

**FFT**

```c++
ll n,m;
vector<complex<double> >a,b;
vector<ll>R;
void DFT(vector<complex<double> >&a,ll n,ll inv){
    for(ll i=0;i<=n;++i){
        if(i<R[i]){
            swap(a[i],a[R[i]]);
        }
    }
    for(ll len=2;len<=n;len<<=1){
        complex<double> wn(cos(2*pi/len),inv*sin(2*pi/len));
        for(ll i=0;i<n;i+=len){
            complex<double>w0(1,0);
            for(ll i2=0;i2<len/2;++i2,w0*=wn){
                complex<double>u=a[i+i2];
                complex<double>v=w0*a[i+i2+len/2];
                a[i+i2]=u+v;
                a[i+i2+len/2]=u-v;
            }
        }
    }
}
void solve(void){
    cin>>n>>m;
    ll len=2,k=1;
    while(len<=n+m)len<<=1,k++;
    R.resize(len+1,0);
    for(ll i=0;i<=len;++i){
        R[i]=(R[i>>1]>>1)|((i&1)<<(k-1));
    }
    a.resize(len+1,complex<double>(0,0));
    b.resize(len+1,complex<double>(0,0));
    for(ll i=0;i<=n;++i){
        ll x;
        cin>>x;
        a[i].real(x);
    }
    for(ll i=0;i<=m;++i){
        ll x;
        cin>>x;
        b[i].real(x);
    }
    DFT(a,len,1);
    DFT(b,len,1);
    for(ll i=0;i<=len;++i){
        a[i]=a[i]*b[i];
    }
    DFT(a,len,-1);
    for(ll i=0;i<=n+m;++i){
        cout<<((ll)(a[i].real()/len+0.5))<<' ';
    }
    cout<<endl;
}
```

___

**NTT**

```c++
const ll MOD=998244353;
const ll G=3;
void NTT(vector<ll>&a,ll n,ll inv){
    for(ll i=0;i<=n;++i){
        if(i<R[i]){
            swap(a[i],a[R[i]]);
        }
    }
    for(ll len=2;len<=n;len<<=1){
        ll wn=q_pow(inv,(MOD-1)/len);
        for(ll i=0;i<n;i+=len){
            ll w0=1;
            for(ll i2=0;i2<len/2;++i2,w0=w0*wn%MOD){
                ll u=a[i+i2];
                ll v=w0*a[i+i2+len/2]%MOD;
                a[i+i2]=(u+v)%MOD;
                a[i+i2+len/2]=(u-v+MOD)%MOD;
            }
        }
    }
}
void solve(void){
    cin>>n>>m;
    ll len=2,k=1;
    while(len<=n+m)len<<=1,k++;
    a.resize(len+1);
    b.resize(len+1);
    R.resize(len+1);
    for(ll i=0;i<=len;++i){
        R[i]=(R[i>>1]>>1)|((i&1)<<(k-1));
    }
    for(ll i=0;i<=n;++i){
        cin>>a[i];
    }
    for(ll i=0;i<=m;++i){
        cin>>b[i];
    }
    NTT(a,len,G);
    NTT(b,len,G);
    for(ll i=0;i<=len;++i){
        a[i]=a[i]*b[i]%MOD;
    }
    NTT(a,len,inv(G));
    ll leninv=inv(len);
    for(ll i=0;i<=n+m;++i){
        cout<<a[i]*leninv%MOD<<' ';
    }
    cout<<endl;
}
```

___

**切比雪夫距离与曼哈顿距离相互转化**
将一个点(x,y)的坐标转化为(x+y,x-y)后，原坐标系中的曼哈顿距离=新坐标系中的切比雪夫距离
将一个点(x,y)的坐标转化为((x+y)/2,(x-y)/2)后，原坐标系中的切比雪夫距离=新坐标系中的曼哈顿距离

___

**神秘数论小知识**
$\sum_{p\leq n}{\frac{1}{p}}=\ln\ln n+O(\frac{1}{\ln n})+M=\ln\ln n+O(1),O(1)\approx0.26$
这个$O(1)$是Meissel-Mertens常数

皮亚诺周期(Pisano Period)
斐波那契数列在模p意义下的循环节总是不超过6p,当且仅当$p=2*5^k$时取等

贝蒂定理
如果两个无理数$a,b$满足
$$\frac{1}{a}+\frac{1}{b}=1$$
那么对于两个集合
$$A=\{[na]\},B=\{[nb]\},n\in Z$$
$$A\cap B=\varnothing,A\cup B=N^+$$

神秘斐波那契小知识

1. $F_n=F_{n-1}+F_{n-2}$,特殊的$F_0=F_1=1$
2. $\sum_{i=0}^{n}{F_i}=F_{n+2}-1$
3. $\sum_{i=1}^{2n-1}F_{i}=F_{2n}$
4. $\sum_{i=0}^{2n}F_{i}=F_{2n+1}-1$
5. $\sum_{i=0}^{n}F_{i}^2=F_{n}F_{n+1}$
6. $F_{n-1}F_{n+1}-F_{n}^2=(-1)^n$
7. $F_{n+2}+F_{n+2}=3F_{n}$
8. $\gcd(F_{n},F_{m})=F_{\gcd(n,m)}$
9. $\gcd(F_{n+m},F_n)=\gcd(F_n,F_m)$
10. $F_{n+m}=F_{m-1}F_{n}+F_{n+1}F_{m}$

___

**神秘数论小结论**
$n=\sum_{d|n}\phi(d);$

$\sum_{x=1}^{n}\sum_{y=1}^{m}\gcd(x,y)=\sum_{d=1}^{\min(n,m)}[\frac{n}{d}][\frac{m}{d}]\cdot \phi(d)$

$\sum_{x=1}^{n}\sum_{y=1}^{m}[\gcd(x,y)=1]=\sum_{d=1}^{\min(n,m)}\mu(d)\cdot [\frac{n}{d}][\frac{m}{d}]$

约数个数$d(i\cdot j)=\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]$

莫反
$[\gcd(i,j)=1]=\sum_{d|\gcd(i,j)}\mu(d)=\sum_{d|i}\sum_{d|j}\mu(d)$

欧反
$n=\sum_{d|n}\phi(d)$

___

**神秘组合数小公式**
错排$D_n=n!\sum_{i=0}^{n}\frac{(-1)^i}{i!}$
容斥原理：设集合$S$有$m$条性质$P_1\dots P_m$，记$S$中有性质$p_i$的元素为集合$A_i$，则集合中至少具有一条性质的元素的个数
$|\cup A_i|=\sum|A_i|-\sum |A_i\cap A_j|+\sum|A_i\cap A_j\cap A_k|-\dots +(-1)^{m+1}|\cap A_i|$
卡特兰数
$H_n=\binom{2n}{n}-\binom{2n}{n-1}\\=\frac{1}{n+1}\binom{2n}{n}$
$H_n=\sum_{i=0}^{n-1}H_iH_{n-i-1}$
第二类斯特林数：
有n个不同的小球，放入k个相同的盒子中，一共有多少种不同的方法
$S(n,k)=S(n-1,k-1)+S(n-1,k)*k$

___

**偏序问题中的定义**
最简单的二维偏序$(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\le a_i\;\text{and}\; b_j\le b_i$的处理方法是选$a$为第一关键词，$b$为第二关键词进行排序；如果必要，将$b$离散化；然后按顺序把$b$一个一个推入树状数组，动态求前缀和。
而其他二维偏序关系，可以作不同的处理转化为最简单的二维偏序。

- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\lt a_i\;\text{and}\; ?$：把第一关键词的小于等于改成小于，需要在对第二关键词排序时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\ge a_i\;\text{and}\; ?$把第一关键词的小于等于改成大于等于，需要在对第一关键词排序时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\gt a_i\;\text{and}\; ?$把第一关键词的小于等于改成大于，需要在对两个关键词排序时都进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$：把第二关键词的小于等于改成小于，查询时使用`query(x-1)`而不是`query(x)`。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$把第二关键词的小于等于改成大于等于，对第二关键词**离散化**时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$把第二关键词的小于等于改成大于等于，对第二关键词**离散化**时进行**逆序排序**，并且查询时使用`query(x-1)`而不是`query(x)`。

___

MEX函数，SG函数打表常用

```c++
int mex(auto v) // v可以是vector、set等容器 
{
    unordered_set<int> S;
    for (auto e : v)
        S.insert(e);
    for (int i = 0;; ++i)
        if (S.find(i) == S.end())
            return i;
}
```

___

**位运算小trick**
**返回一个数的最小二进制位**
可用于树状数组

```c++
ll lowbit(ll x){
    return x&(-x);
}
```

**返回一个数的二进制位的个数**
`__builtin_popcount()`是GCC内置的计算一个数的二进制位中1的个数的函数
可以用于优化某些状压dp
时间复杂度基本为$O(1)$
在`<stdio.h>`中

```c++
int __builtin_popcount(unsigned int u){
    u = (u & 0x55555555) + ((u >> 1) & 0x55555555);
    u = (u & 0x33333333) + ((u >> 2) & 0x33333333);
    u = (u & 0x0F0F0F0F) + ((u >> 4) & 0x0F0F0F0F);
    u = (u & 0x00FF00FF) + ((u >> 8) & 0x00FF00FF);
    u = (u & 0x0000FFFF) + ((u >> 16) & 0x0000FFFF);
    // 源码方法(?)
    return u;
}
int __builtin_popcountl(unsigned long x){
//?
}
int __builtin_popcountll(unsigned long long x){
//?
}
```

**返回一个数的二进制位前导0个数**
`__builtin_clz()`返回一个数的二进制位前导0个数，当x==0时结果未定义
时间复杂度基本为$O(1)$，据说似乎比直接调用数组里的数还要快
可以添加`l`或`ll`来使参数变为`long`或`long long`
可以用于计算以二为底的对数

___

**有关区间内不同数字的个数**
离线下来然后按照r排序，之后每次将位置r上加一，然后将上一个对应的数字的位置减一

___

**Bitset**

```c++
struct DynBitset {
    vector<uint64_t> b;
    ll n; // 位数
    const static ll B = 64;
    DynBitset(ll _n = 0) : n(_n) {
        b.assign((n + B - 1) / B, 0);
    }
    void resize(ll _n) {
        n = _n;
        b.assign((n + B - 1) / B, 0);
    }
    void set(ll i) {
        b[i / B] |= 1ULL << (i % B);
    }
    void reset(ll i) {
        b[i / B] &= ~(1ULL << (i % B));
    }
    void flip(ll i) {
        b[i / B] ^= 1ULL << (i % B);
    }
    bool test(ll i) const {
        return (b[i / B] >> (i % B)) & 1ULL;
    }
    void reset_all() {
        fill(b.begin(), b.end(), 0);
    }
    void flip_all() {
        for (auto &x : b) x = ~x;
        // 最后可能多余的高位
        ll extra = b.size() * B - n;
        if (extra) b.back() &= ((1ULL << (B - extra)) - 1);
    }
    ll count() const {
        ll res = 0;
        for (auto x : b) res += __builtin_popcountll(x);
        return res;
    }
    bool any() const {
        for (auto x : b) if (x) return 1;
        return 0;
    }
    DynBitset operator&(const DynBitset &rhs) const {
        DynBitset res(n);
        for (ll i = 0; i < b.size(); ++i) res.b[i] = b[i] & rhs.b[i];
        return res;
    }
    DynBitset operator|(const DynBitset &rhs) const {
        DynBitset res(n);
        for (ll i = 0; i < b.size(); ++i) res.b[i] = b[i] | rhs.b[i];
        return res;
    }
    DynBitset operator^(const DynBitset &rhs) const {
        DynBitset res(n);
        for (ll i = 0; i < b.size(); ++i) res.b[i] = b[i] ^ rhs.b[i];
        return res;
    }
    DynBitset operator~() const {
        DynBitset res(*this);
        res.flip_all();
        return res;
    }
    void shl(ll k) { // 左移
        if (k >= n) {
            reset_all();
            return;
        }
        ll word = k / B, bit = k % B;
        vector<uint64_t> nb(b.size(), 0);
        for (ll i = b.size() - 1; i >= 0; --i) {
            if (i - word < 0) continue;
            nb[i] |= b[i - word] << bit;
            if (bit && i - word - 1 >= 0) nb[i] |= b[i - word - 1] >> (B - bit);
        }
        b.swap(nb);
        if (b.size() * B > n) b.back() &= ((1ULL << (n % B)) - 1);
    }
    void shr(ll k) { // 右移
        if (k >= n) {
            reset_all();
            return;
        }
        ll word = k / B, bit = k % B;
        vector<uint64_t> nb(b.size(), 0);
        for (ll i = 0; i < b.size(); ++i) {
            if (i + word >= b.size()) continue;
            nb[i] |= b[i + word] >> bit;
            if (bit && i + word + 1 < b.size()) nb[i] |= b[i + word + 1] << (B - bit);
        }
        b.swap(nb);
    }
    ll size() const { return n; }
    void print() const {
        for (ll i = 0; i < n; ++i) cout << test(i);
        cout << endl;
    }
};
```

___

从一个数组中，每次将p个数中每单位最多为k的拿出来，总共n次，最少要拿多少次；
应该使用二分答案

```c++
ll check(ll month){
    ll cnt=month*p,ret=0;
    for(ll i=1;i<=n;++i){
        cnt-=min(month,a[i]/k);
        if(a[i]/k>=month)b[i]=0;
        else b[i]=a[i]%k;
    }
    sort(b+1,b+1+n,greater<ll>());
    if(cnt<=0)return month*p*k;
    ret=(month*p-cnt)*k;
    for(ll i=1;i<=n&&cnt>0;++i,--cnt){
        ret+=b[i];
    }
    return ret;
}
```
