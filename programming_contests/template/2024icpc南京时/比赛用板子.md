


___
**快读**
```c++
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
```
___
**离散化$O(\log{n)}$**
```c++
ll A[N],C[N],L[N];
for(ll i=1;i<=n;++i)C[i]=A[i];
sort(C+1,C+1+n);
ll len=unique(C+1,C+1+n)-C-1;
for(ll i=1;i<=n;++i){
	L[i]=lower_bound(C+1,C+1+len,a[i])-C;
}
```
___
**树状数组**
```c++
inline ll lowbit(ll x){return x&(-x);}
struct Fenwick_tree{
	ll tree[N];
	void update(ll pos,ll k){
		for(ll i=pos;i<=n;i+=lowbit(i))a[i]+=k;
	}
	ll query(ll pos){
		ll res=0;
		for(ll i=pos;i>0;i-=lowbit(i))res+=a[i];
		return res;
	}
}
```
**树状数组特殊运算实现区间加和**
```c++
ll a[N],b[N],t[N];
inline ll lowbit(ll x){
	return x&-x;
}
void update(ll x,ll k){
	for(ll i=x;i<=N;i+=lowbit(i)){
		a[i]+=k;b[i]+=k*x;
	}
}
inline void update(ll l,ll r,ll k){
	update(l,k);
	update(r+1,-k);
}
ll query(ll x){
	ll res=0;
	for(ll i=x;i>0;i-=lowbit(i)){
		res+=(x+1)*a[i]-b[i];
	}
	return res;
}
inline ll query(ll l,ll r){
	return query(r)-query(l-1);
}
```
___
**线段树**
```c++
ll n,q;struct segment_tree{
	ll tree[N<<2],tag[N<<2];
	inline ll ls(ll p){return p<<1LL;}
	inline ll rs(ll p){return (p<<1LL)|1LL;}
	void push_up(ll p){
		tree[p]=tree[ls(p)]+tree[rs(p)];
	}
	void push_down(ll p,ll l,ll r){
		ll mid=l+r>>;
		tree[ls(p)]+=tag[p]*(mid-l+1);
		tree[rs(p)]+=tag[p]*(r-mid);
		tag[ls(p)]+=tag[p];
		tag[rs(p)]+=tag[p];
		tag[p]=0;
	}
	void build(ll p,ll l,ll r){
		if(l==r){tree[p]=a[l];return;}
		ll mid=l+r>>1;
		build(ls(p),l,mid);
		build(rs(p),mid+1,r);
		push_up(p);
	}
	void update(ll nowl,ll nowr,ll l,ll r,ll p,ll k){
		if(l<=nowl&&nowr<=r){
			tree[p]+=k*(nowr-nowl+1);
			tag[p]+=k;
			return;
		}
		ll mid=nowl+nowr>>1;
		push_down(p);
		if(l<=mid)update(nowl,mid,l,r,ls(p),k);
		if(mid+1<=r)update(mid+1,nowr,l,r,rs(p),k);
		push_up(p);
	}
	ll query(ll nowl,ll nowr,ll l,ll r,ll p){
		if(l<=nowl&&nowr<=r){
			return tree[p];
		}
		ll mid=nowl+nowr>>1,ret=0;
		push_down(p);
		if(l<=mid)ret+=query(nowl,mid,l,r,ls(p));
		if(mid+1<=r)ret+=query(mid+1,nowr,l,r,ls(p));
		return ret;
	}
}t;
```
___
**st表 O(1)求区间最小值**
```c++
ll a[N],n,m;
ll st[20][N],lg[N];
ll P=18;
struct st_table{
	ll st[N][20];
	void ini(ll*a){
		for(ll i=1;i<=n;++i)st[0][i]=a[i];
		for(ll i=1;i<=lg[n];++i){
			for(ll i2=1;i2<=n-(1LL<<(i-1));++i2){
				st[i1][i2]=
				min(st[i-1][i2],st[i-1][i2+(1<<(i-1))]);
			}
		}
	}
	ll query(ll l,ll r){
		ll k=lg[r-l+1];
		return min(st[k][l],st[k][r-(1LL<<k)+1]);
	}
}st;
void solve(){
	cin>>n>>m;
	lg[1]=0;
	for(ll i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
	for(ll i=1;i<=n;++i)cin>>a[i];
	st.ini(a);
	while(m--){
		ll l,r;
		cin>>l>>r;
		cout<<st.query(l,r)<<' ';
	}
	cout<<endl;
}
```
___
**单调栈**
可以$O(n)$地扫出来第$i$个元素后面的比$a_i$大的第一个元素的下标
```c++
stack<ll>stk;
for(ll i=n;i>0;--i){
	while(!stk.empty()&&a[stk.top()]<=a[i])stk.pop();
	NGE[i]=stk.empty()?0:stk.top();
	stk.push(i);
}
```
___
**单调队列**
可以$O(n)$的扫出一个长度为n的序列中的所有区间长度为m的区间内的最值
下列每次扫出第i个元素的前m个元素的最小值，如果不够m个从第一个开始，如果前面没有就输出0
```c++
deque<ll>q;
for(ll i=1;i<=n;++i){
	cout<<(q.empty()?0:a[q.front()])<<endl;
	while(!q.empty()&&a[q.back()]>=a[i])q.pop_back();
	q.push_back(i);
	while(q.front()<=i-m)q.pop_front();
}
```
___
**对顶堆**
来自2024icpc第一场G的动态维护前$[\frac{n}{2}+1]$大元素（中位数）
```c++
priority_queue<ll,vector<ll>,greater<ll>>q1;//小根堆
priority_queue<ll,vector<ll>>q2;//大根堆
for(ll i=1;i<=n;++i){
	if(i&1LL){
		q2.push(a[i]);
		q1.push(q2.top());
		q2.pop();
	}else {
		q1.push(a[i]);
		q2.push(q1.top());
		q1.pop();
	}
	if(i&1LL){
		cout<<q1.top()<<endl;
	}
}
```
来自2023南京K的抄的中位数可删板子
```c++
struct medium_solver{
	private:
	multiset<ll>A,B;
	ll SA,SB;
	public:
	//初始化
	void init(void){
		A.clear();B.clear();
		SA=SB=0;
	}
	//插入一个数x
	void insert(ll x){
		if(B.empty()){
			B.insert(x);SB+=x;return;
		}
		ll mid=*B.begin();
		if(x>=mid){
			B.insert(x);SB+=x;
			if(A.size()<B.size()-1){
				auto it=B.begin();SB-=*it,SA+=*it;
				A.insert(*it);B.erase(it);
			}
		}else {
			A.insert(x);SA+=x;
			if(A.size()>B.size()){
				auto it=(--A.end());SA-=*it,SB+=*it;
				B.insert(*it);A.erase(it);
			}
		}
	}
	//删除一个数x
	void remove(ll x){
		ll mid=*B.begin();
		if(x>=mid){
			B.erase(B.find(x));SB-=x;
			if(A.size()>B.size()){
				auto it=(--A.end());SA-=*it,SB+=*it;
				B.insert(*it);A.erase(it);
			}
		}
		else {
			A.erase(A.find(x));SA-=x;
			if(A.size()<B.size()-1){
				auto it=B.begin();SB-=*it,SA+=*it;
				A.insert(*it);B.erase(it);
			}
		}
	}
	//计算题中的某个值
	ll calc(void){
		ll mid=*B.begin();
		return (mid*A.size()-SA)+(SB-mid*B.size());
	}
}s;
```
___
**路径压缩并查集**
```c++
ll fa[N],Rank[N];
void ini(ll x){
	for(ll i=1;i<=x;++i)fa[i]=i,Rank[i]=1;
}
ll find(ll x){
	return (x==fa[x])?x:find(fa[x]);
}
void merge(ll a,ll b){
	ll u=find(a),v=find(b);
	if(u==v)return;
	if(Rank[u]<Rank[v]){
		fa[u]=v;
	}else {
		fa[v]=u;
		if(Rank[u]==Rank[v])Rank[u]++;
	}
}
```
___
**krusktal求最小生成树**
如果tot\=\=n-1则有最小生成树且为sum
每次取不会成环的最小边直到遍历所有点 
```c++
struct EDGE{
	ll to,nxt,val;
}edge[M*2];
ll n,m,q,cnt=0,head[N],fa[N],tot,Rank[N];
void add(ll u,ll v,ll w){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	edge[cnt].val=w;
	head[u]=cnt;
}
ll dsu_find(ll x){
	return x==fa[x]?x:dsu_find(fa[x]);
}
void dsu_ini(ll n){
	for(ll i=1;i<=n;++i)fa[i]=i,Rank[i]=1;
}
void Union(ll a,ll b){
	ll u=dsu_find(a),v=dsu_find(b);
	if(u==v)return;
	if(Rank[u]<Rank[v]){
		fa[u]=v;
	}else {
		fa[v]=u;
		if(Rank[u]==Rank[v])Rank[v]++;
	}
}
bool operator<(const EDGE&a,const EDGE&b){
	return a.val<b.val;
}
ll kruskal(){
	ll sum=0;
	tot=0;
	dsu_ini(n);
	vector<pair<EDGE,ll>>vec;
	for(ll i=1;i<=n;++i){
		for(ll i2=head[i];i2;i2=edge[i2].nxt){
			vec.push_back({edge[i2],i});
		}
	}
	sort(vec.begin(),vec.end());
	for(ll i=0;i<vec.size();++i){
		ll u=vec[i].second,v=vec[i].first.to,w=vec[i].first.val;
		if(dsu_find(u)!=dsu_find(v)){
			tot++;
			sum+=w;
			Union(u,v);
		}
	}
	return sum;
}
```
___
**prim求最小生成树**
若tot\=\=n则有最小生成树为sum
从点开始加最小边直到遍历所有点
```c++
struct EDGE{
	ll to,nxt,val;
}edge[M*2];
ll n,m,q,cnt=0,head[N],dis[N],tot=0,vis[N];
void add(ll u,ll v,ll w){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	edge[cnt].val=w;
	head[u]=cnt;
}
ll prim(){
	tot=0;
	ll sum=0;
	for(ll i=2;i<=n;++i){
		dis[i]=INF;
		vis[i]=0;
	}
	dis[1]=0;
	priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,
	greater<pair<ll,ll>>>q;
	q.push({0,1});
	while(!q.empty()){
		ll val=q.top().first,u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		tot++;
		sum+=val;
		for(ll i=head[u];i;i=edge[i].nxt){
			ll v=edge[i].to,w=edge[i].val;
			if(w<dis[v]){
				dis[v]=w;
				q.push({dis[v],v});
			}
		}
	}
	return sum;
}
```
___
**最短路算法**
**Floyd求多远最短路O(n^3)**
```c++
ll dist[N][N];
void Floyd(){
	for(ll i=1;i<=n;++i)
		for(ll i2=1;i2<=n;++i2)
			dist[i][i2]=INF;
	for(ll i=1;i<=n;++i){
		dist[i][i]=0;
		for(ll u=head[i];u;u=edge[u].next){
			ll v=edge[u].to;
			dist[u][v]=edge[u].val;
		}
	}
	for (ll k = 1; k <= n; k++) {
		for (ll x = 1; x <= n; x++) {
			for (ll y = 1; y <= n; y++) {
				if(dist[x][k]==INF||dist[k][y]==INF)
				continue;
				dist[x][y] = 
				min(dist[x][y], dist[x][k] + dist[k][y]);
			}
		}
	}
}
```
如果想存储路径，则使用path数组，path数组存储的是最近路径，例如：
```c++
a->b->c->d
path[a][d]=b;
path[b][d]=c;
path[c][d]=d;
```
___
**dijkstra算法O(nlogn)单源最短路**
```c++
ll dist[N],pre[N];
bool vis[N];
void dijkstra(ll start,ll end){
	priority_queue<pair<ll,ll>>q;
	for(ll i=1;i<=n;++i)dist[i]=INF,vis[i]=0;
	dist[start]=0;
	q.push(make_pair(0,start));
	while(!q.empty()){
		ll now=q.top().second;q.pop();
		if(vis[now])continue;
		vis[now]=1;
		for(ll u=head[now];u;u=edge[u].next){
			ll v=edge[u].to;
			if(dist[now]+edge[u].val<dist[v]){
				dist[v]=dist[now]+edge[u].val;
				q.push(make_pair(-dist[v],v));
				//pre[v]=u;
			}
		}
	}
}
```
___
**SPFA求单源最短路（可判断负权环）O(nlogn)** 
1. 将除源点之外的所有的点当前距离初始化为无穷，并标记为未入队。源点的当前距离为0，将源点入队。

2. 取出队首u，遍历u的所有出边，检查是否能更新所连接的点v的当前距离。如果v的当前距离被更新并且v不在队中，则将v入队。重复该操作直到队列为空。

3. 检查是否存在负权环的方法为：记录一个点的入队次数，如果超过V-1次说明存在负权环，因为最短路径上除自身外至多V-1个点，故一个点不可能被更新超过V-1次。
```c++
void spfa(ll start){
	queue<ll>q;
	for(ll i=1;i<=n;++i)dist[i]=INF;
	dist[start]=0;
	inque[start]=1;
	q.push(start);
	while(!q.empty()){
		ll u=q.front();
		q.pop();
		inque[u]=0;
		for(ll i=head[u];i;i=edge[i].next){
			ll v=edge[i].to,w=edge[i].val;
			if(dist[v]>dist[u]+w){
				dist[v]=dist[u]+w;
				if(!inque[v]){
					q.push(v);
					inque[v]=1;
				}
			}
		}
	}
}
```
___
**Jhonson算法O(n^2logn)求多源最短路**
> 相当于先用SPFA判断负权环，然后用n次dijkstra
```c++
ll n,m,cnt=0;
struct EDGE{
	ll to,nxt,val;
}edge[N*3];
ll head[N];
void add(ll u,ll v,ll w){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	edge[cnt].val=w;
	head[u]=cnt;
}
ll dist[N],times[N],dist0[N];
bool vis[N];
bool spfa(ll start){
	queue<ll>q;
	for(ll i=1;i<=n;++i)dist0[i]=INF,vis[i]=0,times[i]=0;
	q.push(start);
	dist0[start]=0;
	vis[start]=1;
	while(!q.empty()){
		ll u=q.front();
		q.pop();
		vis[u]=0;
		for(ll i=head[u];i;i=edge[i].nxt){
			ll v=edge[i].to,w=edge[i].val;
			if(dist0[v]>dist0[u]+w){
				dist0[v]=dist0[u]+w;
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
					times[v]++;
					if(times[v]>n)return 0;
				}
			}
		}
	}
	return 1;
}
void dijkstra(ll start){
	priority_queue<pair<ll,ll>>q;
	for(ll i=1;i<=n;++i)dist[i]=INF,vis[i]=0;
	dist[start]=0;
	q.push(make_pair(0,start));
	while(!q.empty()){
		ll u=q.top().second;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(ll i=head[u];i;i=edge[i].nxt){
			ll v=edge[i].to,w=edge[i].val;
			if(dist[v]>dist[u]+w){
				dist[v]=dist[u]+w;
				if(!vis[v])q.push(make_pair(-dist[v],v));
			}
		}
	}
}
```
___
**重链剖分**
```c++
siz[u]//以u为根的子树的结点个数
son[u]//u的重儿子的编号
top[u]//u所在链的深度最小的结点的编号
dep[u]//u的深度
faz[u]//u的父亲结点
dfn[u]//u的dfn序
rk[u]//dfn序对应的结点
```
```c++
vector<ll>e[N];
ll a[N];
ll siz[N],son[N],top[N],dep[N],faz[N],dfn[N],rk[N];
ll idx;
void dfs1(ll fa,ll u){
	siz[u]=1;
	son[u]=0;
	for(ll v:e[u]){
		if(v==fa)continue;
		dep[v]=dep[u]+1;
		faz[v]=u;
		dfs1(u,v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}
void dfs2(ll u,ll rt){
	dfn[u]=++idx;
	rk[idx]=u;
	top[u]=rt;
	if(son[u])dfs2(son[u],rt);
	for(ll v:e[u]){
		if(v==faz[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
void modifyOnChain(ll u,ll v,ll val){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		t.update(1,n,dfn[top[u]],dfn[u],1,val);//Segment_Tree
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	t.update(1,n,dfn[u],dfn[v],1,val);
}
ll queryOnChain(ll u,ll v){
	ll ret=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		ret=(ret+t.query(1,n,dfn[top[u]],dfn[u],1))%mod;//
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	ret=(ret+t.query(1,n,dfn[u],dfn[v],1))%mod;
	return ret;
}
ll lca(ll u,ll v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		u=faz[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	return u;
}
```
___
**dfn序求LCA**
> O(nlogn)预处理O(1)查询
```c++
ll n,m,s;
struct EDGE{
	ll to,nxt;
}e[N<<1];
ll cnt=0,head[N],lg[N];
void add(ll u,ll v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
ll dn,dfn[N],mi[20][N];
inline ll get(ll u,ll v){
	return dfn[u]<dfn[v]?u:v;
}
void dfs(ll f,ll u){
	mi[0][dfn[u]=++dn]=f;
	for(ll i=head[u];i;i=e[i].nxt){
		if(e[i].to!=f)dfs(u,e[i].to);
	}
}
ll LCA(ll u,ll v){
	if(u==v)return u;
	u=dfn[u],v=dfn[v];
	if(u>v)swap(u,v);
	ll d=lg[v-u];
	return get(mi[d][u+1],mi[d][v-(1<<d)+1]);
}
void solve(){
	cin>>n>>m>>s;
	for(ll i=2;i<=n;++i){
		ll u,v;
		cin>>u>>v;add(u,v);add(v,u);
	}
	lg[1]=0;
	for(ll i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
	dfs(0,s);
	for(ll i=1;i<=lg[n];++i){
		for(ll i2=1;i2+(1<<i)-1<=n;++i2){
			mi[i][i2]=get(mi[i-1][i2],mi[i-1][i2+(1<<i-1)]);
		}
	}
	while(m--){
		ll u,v;
		cin>>u>>v;
		cout<<LCA(u,v)<<endl;
	}
}
```
___
**[模版]最长公共子序列**
> 两个n排列
```c++
vector<ll>a(n+1),b(n+1),c(n+1);
map<ll,ll>mp;
for(i=1;i<=n;++i)cin>>a[i],mp[a[i]]=i;
for(i=1;i<=n;++i)cin>>b[i],c[i]=2e5+10;
c[0]=0;
for(i=1;i<=n;++i){
ll l=0,r=ans,mid;
if(mp[b[i]]>c[ans])c[++ans]=mp[b[i]];
else {
/* ll temp=lower_bound(c.begin()+1,c.begin()+ans+1,mp[b[i]],
[&](ll value,ll element)->bool {
return value<mp[element];})-c.begin();
c[temp]=min(c[temp],mp[b[i]]);*/
while(l<r){
	mid=(l+r)>>1;
	if(c[mid]>mp[b[i]])r=mid;
	else l=mid+1;
}
c[l]=min(mp[b[i]],c[l]);
}
}
cout<<ans<<endl;
```
___
**拓扑排序O(n+m)**
> 若需要以字典序排序则只需要将队列换成优先队列即可
```c++
int inde[N],ts[N];//inde[N]表示入度，ts[N]表示拓扑排序的结果。
void toposort(){
	queue<ll>q;
	for(ll i=1;i<=n;++i){
		if(inde[i]==0){
			q.push(i);
		}
	}
	while(!q.empty()){
		ll u=q.front();
		q.pop();
		for(ll i=head[u];i;i=edge[i].next){
			ll v=edge[i].to;
			inde[v]--;
			if(inde[v]==0)q.push(v);
		}
	}
}
```
___
**线性基**
```c++
ll lb[100],cnt;
ll k[100];
void insert(ll x){
	for(ll i=60;i>=0;--i){
		if(!(x&(1LL<<i)))continue;
		if(lb[i])x^=lb[i];
		else {lb[i]=x;break;}
	}
}
void rebuild(){
	for(ll i=0;i<=60;++i){
		for(ll i2=i-1;i2>=0;--i2){
			if(lb[i]&(1LL<<i2))lb[i]^=lb[i2];
		}
	}
	for(ll i=0;i<=60;++i){
		if(lb[i])k[++cnt]=i;
	}
}
```
___
**拉格朗日插值（不实用版）**
$O(n^2)$实现：
```c++
// 朴素拉格朗日插值O(n2)
ll n,k;
ll x[N],y[N],a[N];
ll q_pow(ll base,ll p){
	ll ret=1;
	while(p){
		if(p&1LL)ret=ret*base%MOD;
		base=base*base%MOD;
		p>>=1;
	}
	return ret;
}
inline ll inv(ll x){
	return q_pow(x,MOD-2);
}
void solve(void){
	cin>>n>>k;
	for(ll i=1;i<=n;++i){
		cin>>x[i]>>y[i];
	}
	ll ans=0;
	for(ll i=1;i<=n;++i){
		ll tmp=y[i];
		for(ll i2=1;i2<=n;++i2){
			if(i==i2)continue;
			tmp=(tmp*inv((x[i]-x[i2]+MOD)%MOD))%MOD;
		}
		for(ll i2=1;i2<=n;++i2){
			if(i==i2)continue;
			tmp=(tmp*((k-x[i2]+MOD)%MOD))%MOD;
		}
		ans=(tmp+ans)%MOD;
	}
	cout<<ans<<endl;
}
```
当横坐标是连续整数时的拉格朗日插值
时间复杂度$O(n\log n)$
```c++
ll n,k,cnt=0;
ll y[N],fact[N];
ll pl[N],pr[N];
ll q_pow(ll base,ll p){
	ll ret=1;
	while(p){
		if(p&1LL)ret=ret*base%MOD;
		base=base*base%MOD;
		p>>=1;
	}
	return ret;
}
inline ll inv(ll x){
	return q_pow(x,MOD-2);
}
void ini(ll n){
	fact[0]=fact[1]=1;
	for(ll i=2;i<=n;++i)fact[i]=fact[i-1]*i%MOD;
	for(ll i=1;i<=n;++i)y[i]=(y[i-1]+q_pow(i,k))%MOD;
}
void solve(void){
	cin>>n>>k;
	cnt=k+2;
	ini(cnt);
	ll ans=0;
	if(k+2>=n){
		cout<<y[n]<<endl;
		return;
	}
	pl[0]=1LL;
	pl[1]=(n-1+MOD)%MOD;
	pr[cnt+1]=1LL;
	for(ll i=2;i<=cnt;++i)pl[i]=pl[i-1]*((n-i+MOD)%MOD)%MOD;
	for(ll i=cnt;i>0;--i)pr[i]=pr[i+1]*((n-i+MOD)%MOD)%MOD;
	for(ll i=1;i<=cnt;++i){
		ll tmp=y[i];
		tmp=tmp*pl[i-1]%MOD*pr[i+1]%MOD;
		tmp=tmp*inv(fact[i-1]*fact[cnt-i]%MOD)%MOD;
		if((cnt-i)&1LL)tmp=(MOD-tmp);
		ans=(ans+tmp)%MOD;
	}
	cout<<ans<<endl;
}
```
___
**数论分块**
用$O(sqrt(n))$求出$\sum_{i=l}^{r}f(i)*[\frac{n}{i}]$;
```c++
for(int l = 1, r; l <= n; l = r + 1) {
	r = n / (n / l);
	ans += (r - l + 1) * (n / l)
}
```
___
**线性求逆元（不会）**
```c++
inv[1] = 1;
for (int i = 2; i <= n; ++i) {
inv[i] = (long long)(p - p / i) * inv[p % i] % p;
}
```
___
**拓展欧几里得求逆元（不会）**
```c++
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(b==0)
	{
		x=1;
		y=0;
		return a;
	}
	ll ans=exgcd(b,a%b,x,y);
	ll temp=x;
	x=y;
	y=temp-a/b*y;
	return ans;
}
ll inv(ll a,ll p)
{
	ll x,y;
	ll g=exgcd(a,p,x,y);
	if(g!=1) return -1;//不互质则无解
	else return (x%p+p)%p;
}
```
___
**素数筛-埃氏筛(埃拉托斯特尼筛法)O(nloglogn)**
```c++
bool vis[N];
ll prime[N];
ll Eratosthenes_sieve(ll n){
	ll i,i2,k=0;
	for(i=0;i<=N;++i)vis[i]=0;
	vis[0]=vis[1]=0;
	for(i=2;i<=n;++i){
		if(vis[i]==0){
			prime[++k]=i;
			for(i2=i;i2*i<=n;++i2)vis[i2*i]=1;
		}
	}
	return k;
}
```
___
**欧拉筛-线性筛O(n)**
```c++
bool vis[N];
ll prime[N],k=0;
void ola_sieve(ll n){
	for(ll i=2;i<=n;++i){
		if(vis[i]==0)prime[++k]=i;
		for(ll i2=1;i*prime[i2]<=n;++i2){
			vis[prime[i2]*i]=1;
			if(i%prime[i2]==0)break;
		}
	}
}
```
**可求欧拉函数**
```c++
ll phi[N],phi_sum[N];
ll vis[N];
ll prime[N],cnt=0;
void e_phi(ll x){
	vis[0]=vis[1]=1;
	phi[1]=1;cnt=0;
	for(ll i=2;i<=x;++i)vis[i]=0;
	for(ll i=2;i<=x;++i){
		if(!vis[i])prime[++cnt]=i,phi[i]=i-1;
		for(ll i2=1;i2<=cnt&&i*prime[i2]<=x;++i2){
			vis[prime[i2]*i]=1;
			if(i%prime[i2]==0){
				phi[i*prime[i2]]=phi[i]*prime[i2];
				break;
			}
			else phi[i*prime[i2]]=phi[i]*(prime[i2]-1);
		}
	}
	for(ll i=1;i<=x;++i)phi_sum[i]=phi_sum[i-1]+phi[i];
}
```
___
**miller-rabin算法O(logn)求是否为质数**
```c++
inline ll Abs(ll x){
	return x<0?-x:x;
}
ll q_pow(ll base,ll p,ll mod){
	ll ret=1LL;
	while(p){
		if(p&1LL)ret=(lll)ret*(lll)base%mod;
		base=(lll)base*(lll)base%mod;
		p>>=1;
	}
	return ret;
}
ll gcd(ll a,ll b){
	ll r=1;
	while(r){
		r=a%b;
		a=b;
		b=r;
	}
	return a;
}

mt19937 rd(time(NULL)*(time(NULL)+114514));
const ll test_prime[]={2,3,5,7,11,13,17,19,23,29,31,37};
bool mr(ll base,ll n){
	if(q_pow(base,n-1,n)!=1)return 0;
	ll u=n-1,t=0;
	while(!(u&1LL)){
		u>>=1;
		ll tmp=q_pow(base,u,n);
		if(tmp!=1&&tmp!=n-1)return 0;
		if(tmp==n-1)return 1;
	}
	return 1;
}
inline bool is_prime(ll n){
	if(n>40){
		for(ll test:test_prime)
			if(!mr(test,n))return 0;
		return 1;
	}
	for(ll test:test_prime){
		if(n==test)return 1;
	}
	return 0;
}
```
___
**Prho算法$O(n^{\frac{1}{4}})$分解质因数**
```c++
ll rho(ll n){
	ll s=0,t=0,c=1LL*rd()%(n-1)+1;
	ll stp=0,goal=1;
	ll val=1;
	for(goal=1;;goal<<=1,s=t,val=1){
		for(stp=1;stp<=goal;++stp){
			t=f(t,c,n);
			val=(lll)val*Abs(s-t)%n;
			if((stp%127)==0){
				ll d=gcd(val,n);
				if(d>1)return d;
			}
		}
		ll d=gcd(val,n);
		if(d>1)return d;
	}
}
ll fact[256],tot=0;
void prho(ll x){
	if(x<2)return;
	if(is_prime(x)){
		fact[++tot]=x;
		return ;
	}
	ll pi=rho(x);
	while(pi>=x)pi=rho(x);
	// while(x%pi==0){x/=pi;}
	prho(pi);
	prho(x/pi);
}
ll p[128],cnt[128],ccnt=0;
```
___
**线性筛求莫比乌斯函数**
```c++
void getMu() {
mu[1] = 1;
for (int i = 2; i <= n; ++i) {
	if (!flg[i]) p[++tot] = i, mu[i] = -1;
	for (int j = 1; j <= tot && i * p[j] <= n; ++j) {
	flg[i * p[j]] = 1;
	if (i % p[j] == 0) {
		mu[i * p[j]] = 0;
		break;
	}
	mu[i * p[j]] = -mu[i];
	}
}
}
```
___
**神秘数论小知识**
$\sum_{p\leq n}{\frac{1}{p}}=\ln\ln n+O(\frac{1}{\ln n})+M=\ln\ln n+O(1),O(1)\approx0.26$
这个$O(1)$是Meissel-Mertens常数

皮亚诺周期(Pisano Period)
斐波那契数列在模p意义下的循环节总是不超过6p,当且仅当$p=2*5^k$时取等

贝蒂定理
如果两个无理数$a,b$满足
$$\frac{1}{a}+\frac{1}{b}=1$$
那么对于两个集合
$$A=\{[na]\},B=\{[nb]\},n\in Z$$
$$A\cap B=\varnothing,A\cup B=N^+$$

神秘斐波那契小知识
1. $F_n=F_{n-1}+F_{n-2}$,特殊的$F_0=F_1=1$
2. $\sum_{i=0}^{n}{F_i}=F_{n+2}-1$
3. $\sum_{i=1}^{2n-1}F_{i}=F_{2n}$
4. $\sum_{i=0}^{2n}F_{i}=F_{2n+1}-1$
5. $\sum_{i=0}^{n}F_{i}^2=F_{n}F_{n+1}$
6. $F_{n-1}F_{n+1}-F_{n}^2=(-1)^n$
7. $F_{n+2}+F_{n+2}=3F_{n}$
8. $\gcd(F_{n},F_{m})=F_{\gcd(n,m)}$
9. $\gcd(F_{n+m},F_n)=\gcd(F_n,F_m)$
10. $F_{n+m}=F_{m-1}F_{n}+F_{n+1}F_{m}$
___
**神秘数论小结论**
$n=\sum_{d|n}\phi(d);$

$\sum_{x=1}^{n}\sum_{y=1}^{m}\gcd(x,y)=\sum_{d=1}^{\min(n,m)}[\frac{n}{d}][\frac{m}{d}]\cdot \phi(d)$

$\sum_{x=1}^{n}\sum_{y=1}^{m}[\gcd(x,y)=1]=\sum_{d=1}^{\min(n,m)}\mu(d)\cdot [\frac{n}{d}][\frac{m}{d}]$

约数个数$d(i\cdot j)=\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]$

莫反
$[\gcd(i,j)=1]=\sum_{d|\gcd(i,j)}\mu(d)=\sum_{d|i}\sum_{d|j}\mu(d)$

欧反
$n=\sum_{d|n}\phi(d)$

___
**神秘组合数小公式**
错排$D_n=n!\sum_{i=0}^{n}\frac{(-1)^i}{i!}$
容斥原理：设集合$S$有$m$条性质$P_1\dots P_m$，记$S$中有性质$p_i$的元素为集合$A_i$，则集合中至少具有一条性质的元素的个数
$|\cup A_i|=\sum|A_i|-\sum |A_i\cap A_j|+\sum|A_i\cap A_j\cap A_k|-\dots +(-1)^{m+1}|\cap A_i|$
卡特兰数
$H_n=\binom{2n}{n}-\binom{2n}{n-1}\\=\frac{1}{n+1}\binom{2n}{n}$
$H_n=\sum_{i=0}^{n-1}H_iH_{n-i-1}$
___
**偏序问题中的定义**
最简单的二维偏序$(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\le a_i\;\text{and}\; b_j\le b_i$的处理方法是选$a$为第一关键词，$b$为第二关键词进行排序；如果必要，将$b$离散化；然后按顺序把$b$一个一个推入树状数组，动态求前缀和。
而其他二维偏序关系，可以作不同的处理转化为最简单的二维偏序。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\lt a_i\;\text{and}\; ?$：把第一关键词的小于等于改成小于，需要在对第二关键词排序时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\ge a_i\;\text{and}\; ?$把第一关键词的小于等于改成大于等于，需要在对第一关键词排序时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\gt a_i\;\text{and}\; ?$把第一关键词的小于等于改成大于，需要在对两个关键词排序时都进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$：把第二关键词的小于等于改成小于，查询时使用`query(x-1)`而不是`query(x)`。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$把第二关键词的小于等于改成大于等于，对第二关键词**离散化**时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$把第二关键词的小于等于改成大于等于，对第二关键词**离散化**时进行**逆序排序**，并且查询时使用`query(x-1)`而不是`query(x)`。
___
MEX函数，SG函数打表常用
```c++
int mex(auto v) // v可以是vector、set等容器 
{
    unordered_set<int> S;
    for (auto e : v)
        S.insert(e);
    for (int i = 0;; ++i)
        if (S.find(i) == S.end())
            return i;
}
```
___