___
**快读**
```c++
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
```
___
**离散化$O(\log{n)}$**
```c++
ll A[N],C[N],L[N];
for(ll i=1;i<=n;++i)C[i]=A[i];
sort(C+1,C+1+n);
ll len=unique(C+1,C+1+n)-C-1;
for(ll i=1;i<=n;++i){
	L[i]=lower_bound(C+1,C+1+len,a[i])-C;
}
```
___
**素数筛-埃氏筛(埃拉托斯特尼筛法)O(nloglogn)**
```c++
bool vis[N];
ll prime[N];
ll Eratosthenes_sieve(ll n){
	ll i,i2,k=0;
	for(i=0;i<=N;++i)vis[i]=0;
	vis[0]=vis[1]=0;
	for(i=2;i<=n;++i){
		if(vis[i]==0){
			prime[++k]=i;
			for(i2=i;i2*i<=n;++i2)vis[i2*i]=1;
		}
	}
	return k;
}
```
___
**欧拉筛-线性筛O(n)**
```c++
bool vis[N];
ll prime[N],k=0;
void ola_sieve(ll n){
	for(ll i=2;i<=n;++i){
		if(vis[i]==0)prime[++k]=i;
		for(ll i2=1;i*prime[i2]<=n;++i2){
			vis[prime[i2]*i]=1;
			if(i%prime[i2]==0)break;
		}
	}
}
```
**可求欧拉函数**
```c++
ll phi[N],phi_sum[N];
ll vis[N];
ll prime[N],cnt=0;
void e_phi(ll x){
	vis[0]=vis[1]=1;
	phi[1]=1;cnt=0;
	for(ll i=2;i<=x;++i)vis[i]=0;
	for(ll i=2;i<=x;++i){
		if(!vis[i])prime[++cnt]=i,phi[i]=i-1;
		for(ll i2=1;i2<=cnt&&i*prime[i2]<=x;++i2){
			vis[prime[i2]*i]=1;
			if(i%prime[i2]==0){
				phi[i*prime[i2]]=phi[i]*prime[i2];
				break;
			}
			else phi[i*prime[i2]]=phi[i]*(prime[i2]-1);
		}
	}
	for(ll i=1;i<=x;++i)phi_sum[i]=phi_sum[i-1]+phi[i];
}
```
___
**miller-rabin算法O(logn)求是否为质数**
```c++
inline ll Abs(ll x){
	return x<0?-x:x;
}
ll q_pow(ll base,ll p,ll mod){
	ll ret=1LL;
	while(p){
		if(p&1LL)ret=(lll)ret*(lll)base%mod;
		base=(lll)base*(lll)base%mod;
		p>>=1;
	}
	return ret;
}
ll gcd(ll a,ll b){
	ll r=1;
	while(r){
		r=a%b;
		a=b;
		b=r;
	}
	return a;
}

mt19937 rd(time(NULL)*(time(NULL)+114514));
const ll test_prime[]={2,3,5,7,11,13,17,19,23,29,31,37};
bool mr(ll base,ll n){
	if(q_pow(base,n-1,n)!=1)return 0;
	ll u=n-1,t=0;
	while(!(u&1LL)){
		u>>=1;
		ll tmp=q_pow(base,u,n);
		if(tmp!=1&&tmp!=n-1)return 0;
		if(tmp==n-1)return 1;
	}
	return 1;
}
inline bool is_prime(ll n){
	if(n>40){
		for(ll test:test_prime)
			if(!mr(test,n))return 0;
		return 1;
	}
	for(ll test:test_prime){
		if(n==test)return 1;
	}
	return 0;
}
```
___
**Prho算法$O(n^{\frac{1}{4}})$分解质因数**
```c++
ll rho(ll n){
	ll s=0,t=0,c=1LL*rd()%(n-1)+1;
	ll stp=0,goal=1;
	ll val=1;
	for(goal=1;;goal<<=1,s=t,val=1){
		for(stp=1;stp<=goal;++stp){
			t=f(t,c,n);
			val=(lll)val*Abs(s-t)%n;
			if((stp%127)==0){
				ll d=gcd(val,n);
				if(d>1)return d;
			}
		}
		ll d=gcd(val,n);
		if(d>1)return d;
	}
}
ll fact[256],tot=0;
void prho(ll x){
	if(x<2)return;
	if(is_prime(x)){
		fact[++tot]=x;
		return ;
	}
	ll pi=rho(x);
	while(pi>=x)pi=rho(x);
	// while(x%pi==0){x/=pi;}
	prho(pi);
	prho(x/pi);
}
ll p[128],cnt[128],ccnt=0;
```
___
**树状数组**
```c++
inline ll lowbit(ll x){return x&(-x);}
struct Fenwick_tree{
	ll tree[N];
	void update(ll pos,ll k){
		for(ll i=pos;i<=n;i+=lowbit(i))a[i]+=k;
	}
	ll query(ll pos){
		ll res=0;
		for(ll i=pos;i>0;i-=lowbit(i))res+=a[i];
		return res;
	}
}
```
**树状数组特殊运算实现区间加和**
```c++
ll a[N],b[N],t[N];
inline ll lowbit(ll x){
	return x&-x;
}
void update(ll x,ll k){
	for(ll i=x;i<=N;i+=lowbit(i)){
		a[i]+=k;b[i]+=k*x;
	}
}
inline void update(ll l,ll r,ll k){
	update(l,k);
	update(r+1,-k);
}
ll query(ll x){
	ll res=0;
	for(ll i=x;i>0;i-=lowbit(i)){
		res+=(x+1)*a[i]-b[i];
	}
	return res;
}
inline ll query(ll l,ll r){
	return query(r)-query(l-1);
}
```
___
**线段树**
```c++
ll n,q;struct segment_tree{
	ll tree[N<<2],tag[N<<2];
	inline ll ls(ll p){return p<<1LL;}
	inline ll rs(ll p){return (p<<1LL)|1LL;}
	void push_up(ll p){
		tree[p]=tree[ls(p)]+tree[rs(p)];
	}
	void push_down(ll p,ll l,ll r){
		ll mid=l+r>>;
		tree[ls(p)]+=tag[p]*(mid-l+1);
		tree[rs(p)]+=tag[p]*(r-mid);
		tag[ls(p)]+=tag[p];
		tag[rs(p)]+=tag[p];
		tag[p]=0;
	}
	void build(ll p,ll l,ll r){
		if(l==r){tree[p]=a[l];return;}
		ll mid=l+r>>1;
		build(ls(p),l,mid);
		build(rs(p),mid+1,r);
		push_up(p);
	}
	void update(ll nowl,ll nowr,ll l,ll r,ll p,ll k){
		if(l<=nowl&&nowr<=r){
			tree[p]+=k*(nowr-nowl+1);
			tag[p]+=k;
			return;
		}
		ll mid=nowl+nowr>>1;
		push_down(p);
		if(l<=mid)update(nowl,mid,l,r,ls(p),k);
		if(mid+1<=r)update(mid+1,nowr,l,r,rs(p),k);
		push_up(p);
	}
	ll query(ll nowl,ll nowr,ll l,ll r,ll p){
		if(l<=nowl&&nowr<=r){
			return tree[p];
		}
		ll mid=nowl+nowr>>1,ret=0;
		push_down(p);
		if(l<=mid)ret+=query(nowl,mid,l,r,ls(p));
		if(mid+1<=r)ret+=query(mid+1,nowr,l,r,ls(p));
		return ret;
	}
}t;
```
___
**st表 O(1)求区间最小值**
```c++
ll a[N],n,m;
ll st[20][N],lg[N];
ll P=18;
struct st_table{
	ll st[N][20];
	void ini(ll*a){
		for(ll i=1;i<=n;++i)st[0][i]=a[i];
		for(ll i=1;i<=lg[n];++i){
			for(ll i2=1;i2<=n-(1LL<<(i-1));++i2){
				st[i1][i2]=min(st[i-1][i2],st[i-1][i2+(1<<(i-1))]);
			}
		}
	}
	ll query(ll l,ll r){
		ll k=lg[r-l+1];
		return min(st[k][l],st[k][r-(1LL<<k)+1]);
	}
}st;
void solve(){
	cin>>n>>m;
	lg[1]=0;
	for(ll i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
	for(ll i=1;i<=n;++i)cin>>a[i];
	st.ini(a);
	while(m--){
		ll l,r;
		cin>>l>>r;
		cout<<st.query(l,r)<<' ';
	}
	cout<<endl;
}
```
___
**路径压缩并查集**
```c++
ll fa[N],Rank[N];
void ini(ll x){
	for(ll i=1;i<=x;++i)fa[i]=i,Rank[i]=1;
}
ll find(ll x){
	return (x==fa[x])?x:find(fa[x]);
}
void merge(ll a,ll b){
	ll u=find(a),v=find(b);
	if(u==v)return;
	if(Rank[u]<Rank[v]){
		fa[u]=v;
	}else {
		fa[v]=u;
		if(Rank[u]==Rank[v])Rank[u]++;
	}
}
```
___
**krusktal求最小生成树**
如果tot\=\=n-1则有最小生成树且为sum
每次取不会成环的最小边直到遍历所有点 
```c++
struct EDGE{
	ll to,nxt,val;
}edge[M*2];
ll n,m,q,cnt=0,head[N],fa[N],tot,Rank[N];
void add(ll u,ll v,ll w){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	edge[cnt].val=w;
	head[u]=cnt;
}
ll dsu_find(ll x){
	return x==fa[x]?x:dsu_find(fa[x]);
}
void dsu_ini(ll n){
	for(ll i=1;i<=n;++i)fa[i]=i,Rank[i]=1;
}
void Union(ll a,ll b){
	ll u=dsu_find(a),v=dsu_find(b);
	if(u==v)return;
	if(Rank[u]<Rank[v]){
		fa[u]=v;
	}else {
		fa[v]=u;
		if(Rank[u]==Rank[v])Rank[v]++;
	}
}
bool operator<(const EDGE&a,const EDGE&b){
	return a.val<b.val;
}
ll kruskal(){
	ll sum=0;
	tot=0;
	dsu_ini(n);
	vector<pair<EDGE,ll>>vec;
	for(ll i=1;i<=n;++i){
		for(ll i2=head[i];i2;i2=edge[i2].nxt){
			vec.push_back({edge[i2],i});
		}
	}
	sort(vec.begin(),vec.end());
	for(ll i=0;i<vec.size();++i){
		ll u=vec[i].second,v=vec[i].first.to,w=vec[i].first.val;
		if(dsu_find(u)!=dsu_find(v)){
			tot++;
			sum+=w;
			Union(u,v);
		}
	}
	return sum;
}
```
___
**prim求最小生成树**
若tot\=\=n则有最小生成树为sum
从点开始加最小边直到遍历所有点
```c++
struct EDGE{
	ll to,nxt,val;
}edge[M*2];
ll n,m,q,cnt=0,head[N],dis[N],tot=0,vis[N];
void add(ll u,ll v,ll w){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	edge[cnt].val=w;
	head[u]=cnt;
}
ll prim(){
	tot=0;
	ll sum=0;
	for(ll i=2;i<=n;++i){
		dis[i]=INF;
		vis[i]=0;
	}
	dis[1]=0;
	priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>q;
	q.push({0,1});
	while(!q.empty()){
		ll val=q.top().first,u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		tot++;
		sum+=val;
		for(ll i=head[u];i;i=edge[i].nxt){
			ll v=edge[i].to,w=edge[i].val;
			if(w<dis[v]){
				dis[v]=w;
				q.push({dis[v],v});
			}
		}
	}
	return sum;
}
```
___
**最短路算法**
**Floyd求多远最短路O(n^3)**
```c++
ll dist[N][N];
void Floyd(){
	for(ll i=1;i<=n;++i)
		for(ll i2=1;i2<=n;++i2)
			dist[i][i2]=INF;
	for(ll i=1;i<=n;++i){
		dist[i][i]=0;
		for(ll u=head[i];u;u=edge[u].next){
			ll v=edge[u].to;
			dist[u][v]=edge[u].val;
		}
	}
	for (ll k = 1; k <= n; k++) {
		for (ll x = 1; x <= n; x++) {
			for (ll y = 1; y <= n; y++) {
				if(dist[x][k]==INF||dist[k][y]==INF)continue;
				dist[x][y] = min(dist[x][y], dist[x][k] + dist[k][y]);
			}
		}
	}
}
```
如果想存储路径，则使用path数组，path数组存储的是最近路径，例如：
```c++
a->b->c->d
path[a][d]=b;
path[b][d]=c;
path[c][d]=d;
```
___
**dijkstra算法O(nlogn)单源最短路**
```c++
ll dist[N],pre[N];
bool vis[N];
void dijkstra(ll start,ll end){
	priority_queue<pair<ll,ll>>q;
	for(ll i=1;i<=n;++i)dist[i]=INF,vis[i]=0;
	dist[start]=0;
	q.push(make_pair(0,start));
	while(!q.empty()){
		ll now=q.top().second;q.pop();
		if(vis[now])continue;
		vis[now]=1;
		for(ll u=head[now];u;u=edge[u].next){
			ll v=edge[u].to;
			if(dist[now]+edge[u].val<dist[v]){
				dist[v]=dist[now]+edge[u].val;
				q.push(make_pair(-dist[v],v));
				//pre[v]=u;
			}
		}
	}
}
```
___
**SPFA求单源最短路（可判断负权环）O(nlogn)** 
1. 将除源点之外的所有的点当前距离初始化为无穷，并标记为未入队。源点的当前距离为0，将源点入队。

2. 取出队首u，遍历u的所有出边，检查是否能更新所连接的点v的当前距离。如果v的当前距离被更新并且v不在队中，则将v入队。重复该操作直到队列为空。

3. 检查是否存在负权环的方法为：记录一个点的入队次数，如果超过V-1次说明存在负权环，因为最短路径上除自身外至多V-1个点，故一个点不可能被更新超过V-1次。
```c++
void spfa(ll start){
	queue<ll>q;
	for(ll i=1;i<=n;++i)dist[i]=INF;
	dist[start]=0;
	inque[start]=1;
	q.push(start);
	while(!q.empty()){
		ll u=q.front();
		q.pop();
		inque[u]=0;
		for(ll i=head[u];i;i=edge[i].next){
			ll v=edge[i].to,w=edge[i].val;
			if(dist[v]>dist[u]+w){
				dist[v]=dist[u]+w;
				if(!inque[v]){
					q.push(v);
					inque[v]=1;
				}
			}
		}
	}
}
```
___
**Jhonson算法O(n^2logn)求多源最短路**
> 相当于先用SPFA判断负权环，然后用n次dijkstra
```c++
ll n,m,cnt=0;
struct EDGE{
	ll to,nxt,val;
}edge[N*3];
ll head[N];
void add(ll u,ll v,ll w){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	edge[cnt].val=w;
	head[u]=cnt;
}
ll dist[N],times[N],dist0[N];
bool vis[N];
bool spfa(ll start){
	queue<ll>q;
	for(ll i=1;i<=n;++i)dist0[i]=INF,vis[i]=0,times[i]=0;
	q.push(start);
	dist0[start]=0;
	vis[start]=1;
	while(!q.empty()){
		ll u=q.front();
		q.pop();
		vis[u]=0;
		for(ll i=head[u];i;i=edge[i].nxt){
			ll v=edge[i].to,w=edge[i].val;
			if(dist0[v]>dist0[u]+w){
				dist0[v]=dist0[u]+w;
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
					times[v]++;
					if(times[v]>n)return 0;
				}
			}
		}
	}
	return 1;
}
void dijkstra(ll start){
	priority_queue<pair<ll,ll>>q;
	for(ll i=1;i<=n;++i)dist[i]=INF,vis[i]=0;
	dist[start]=0;
	q.push(make_pair(0,start));
	while(!q.empty()){
		ll u=q.top().second;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(ll i=head[u];i;i=edge[i].nxt){
			ll v=edge[i].to,w=edge[i].val;
			if(dist[v]>dist[u]+w){
				dist[v]=dist[u]+w;
				if(!vis[v])q.push(make_pair(-dist[v],v));
			}
		}
	}
}
```
___
**数论分块**
用O(sqrt(n))求出sum_{i=l}^{r}f(i)*[n/i];
```c++
for(int l = 1, r; l <= n; l = r + 1) {
	r = n / (n / l);
	ans += (r - l + 1) * (n / l)
}
```
___
**dfn序求LCA**
> O(nlogn)预处理O(1)查询
```c++
ll n,m,s;
struct EDGE{
	ll to,nxt;
}e[N<<1];
ll cnt=0,head[N],lg[N];
void add(ll u,ll v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
ll dn,dfn[N],mi[20][N];
inline ll get(ll u,ll v){
	return dfn[u]<dfn[v]?u:v;
}
void dfs(ll f,ll u){
	mi[0][dfn[u]=++dn]=f;
	for(ll i=head[u];i;i=e[i].nxt){
		if(e[i].to!=f)dfs(u,e[i].to);
	}
}
ll LCA(ll u,ll v){
	if(u==v)return u;
	u=dfn[u],v=dfn[v];
	if(u>v)swap(u,v);
	ll d=lg[v-u];
	return get(mi[d][u+1],mi[d][v-(1<<d)+1]);
}
void solve(){
	cin>>n>>m>>s;
	for(ll i=2;i<=n;++i){
		ll u,v;
		cin>>u>>v;add(u,v);add(v,u);
	}
	lg[1]=0;
	for(ll i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
	dfs(0,s);
	for(ll i=1;i<=lg[n];++i){
		for(ll i2=1;i2+(1<<i)-1<=n;++i2){
			mi[i][i2]=get(mi[i-1][i2],mi[i-1][i2+(1<<i-1)]);
		}
	}
	while(m--){
		ll u,v;
		cin>>u>>v;
		cout<<LCA(u,v)<<endl;
	}
}
```
___
**[模版]最长公共子序列**
> 两个n排列
```c++
vector<ll>a(n+1),b(n+1),c(n+1);
map<ll,ll>mp;
for(i=1;i<=n;++i)cin>>a[i],mp[a[i]]=i;
for(i=1;i<=n;++i)cin>>b[i],c[i]=2e5+10;
c[0]=0;
for(i=1;i<=n;++i){
ll l=0,r=ans,mid;
if(mp[b[i]]>c[ans])c[++ans]=mp[b[i]];
else {
// ll temp=lower_bound(c.begin()+1,c.begin()+ans+1,mp[b[i]],[&](ll value,ll element)->bool {return value<mp[element];})-c.begin();
// c[temp]=min(c[temp],mp[b[i]]);
while(l<r){
	mid=(l+r)>>1;
	if(c[mid]>mp[b[i]])r=mid;
	else l=mid+1;
}
c[l]=min(mp[b[i]],c[l]);
}
}
cout<<ans<<endl;
```
___
**拓扑排序O(n+m)**
> 若需要以字典序排序则只需要将队列换成优先队列即可
```c++
int inde[N],ts[N];//inde[N]表示入度，ts[N]表示拓扑排序的结果。
void toposort(){
	queue<ll>q;
	for(ll i=1;i<=n;++i){
		if(inde[i]==0){
			q.push(i);
		}
	}
	while(!q.empty()){
		ll u=q.front();
		q.pop();
		for(ll i=head[u];i;i=edge[i].next){
			ll v=edge[i].to;
			inde[v]--;
			if(inde[v]==0)q.push(v);
		}
	}
}
```
___
**线性求逆元（不会）**
```c++
inv[1] = 1;
for (int i = 2; i <= n; ++i) {
inv[i] = (long long)(p - p / i) * inv[p % i] % p;
}
```
___
**拓展欧几里得求逆元（不会）**
```c++
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(b==0)
	{
		x=1;
		y=0;
		return a;
	}
	ll ans=exgcd(b,a%b,x,y);
	ll temp=x;
	x=y;
	y=temp-a/b*y;
	return ans;
}
ll inv(ll a,ll p)
{
	ll x,y;
	ll g=exgcd(a,p,x,y);
	if(g!=1) return -1;//不互质则无解
	else return (x%p+p)%p;
}
```
___
**线性筛求默比乌斯函数**
```c++
void getMu() {
mu[1] = 1;
for (int i = 2; i <= n; ++i) {
	if (!flg[i]) p[++tot] = i, mu[i] = -1;
	for (int j = 1; j <= tot && i * p[j] <= n; ++j) {
	flg[i * p[j]] = 1;
	if (i % p[j] == 0) {
		mu[i * p[j]] = 0;
		break;
	}
	mu[i * p[j]] = -mu[i];
	}
}
}
```
___
**神秘数论小知识**
$n=\sum_{d|n}\phi(d);$
___
**偏序问题中的定义**
最简单的二维偏序$(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\le a_i\;\text{and}\; b_j\le b_i$的处理方法是选$a$为第一关键词，$b$为第二关键词进行排序；如果必要，将$b$离散化；然后按顺序把$b$一个一个推入树状数组，动态求前缀和。
而其他二维偏序关系，可以作不同的处理转化为最简单的二维偏序。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\lt a_i\;\text{and}\; ?$：把第一关键词的小于等于改成小于，需要在对第二关键词排序时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\ge a_i\;\text{and}\; ?$把第一关键词的小于等于改成大于等于，需要在对第一关键词排序时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\; a_j\gt a_i\;\text{and}\; ?$把第一关键词的小于等于改成大于，需要在对两个关键词排序时都进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$：把第二关键词的小于等于改成小于，查询时使用`query(x-1)`而不是`query(x)`。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$把第二关键词的小于等于改成大于等于，对第二关键词**离散化**时进行**逆序排序**。
- $(a_j,b_j)\prec(a_i,b_i) \;\xlongequal{def}\;?\;\text{and}\; b_j\lt b_i$把第二关键词的小于等于改成大于等于，对第二关键词**离散化**时进行**逆序排序**，并且查询时使用`query(x-1)`而不是`query(x)`。
___
