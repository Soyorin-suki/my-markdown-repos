___

# 1. 算法竞赛中的数论

数论是研究整数性质的重要数学分支。在生活中也存在相当多的与整数相关的问题，因而作为解决问题的算法竞赛中，也存在许多与整数相关的题目，为了解决这些题目，我们有必要学习数论。

今天我们将学习下面这些知识：
> 模运算即模运算的运算规律\
> 费马小定理快速幂求逆元\
> 质数\
> 筛法\
> 质因数分解\
> gcd以及如何求取gcd\
> 拓展：\
> 相关trick

# 2. 模运算

## 2.1 为什么要取模
首先作为计数题目和概率题目的常客，我们先学习一下**模运算**\
为什么要取模？很多问题答案的实际数字可能很大，超出了常见的整型变量的取值范围，如果考察高精度的话有些时候不太现实，此时为了避免输出大数字和引入高精度，题目常常要求对答案取模。这就要求熟练掌握模运算。
## 2.2 取模是什么
取模，在C++中用`%`来表示，在数学中，我们使用$a\mod b$表示对a对b取模，其中$a\mod b=a-\lfloor \frac{a}{b} \rfloor\cdot b$。在此我们先不考虑a和b的符号，默认a为非负整数，b为正整数。\
其中$\lfloor\rfloor$是向下取整符号。\
可以将其理解为将数字映射到一个仅有$\{0,1,...,b-1\}$的集合中

## 2.3 模运算的性质
$a\equiv b\pmod m$表示的是$a\mod m=b\mod m$，也可以理解为$m|(a-b)$，这里的$|$是整除符号，意为$a-b=km,k\in N$\
如果$a\equiv b\pmod p$的话：\
$a+c\equiv b+c\pmod p$这里的$\equiv$相当于模运算下的等号\
$a-c\equiv b-c\pmod p$\
$ac\equiv bc\pmod p$\
注意$\frac{a}{c}\equiv \frac{b}{c}\pmod p$不一定成立！\
例如$\frac{3}{2}\not\equiv\frac{7}{2}\pmod 4$\
这里会出现分数，而在模运算的世界中不存在分数，因此我们不能直接除\
我们可以发现在模运算下四则运算只能实现加减乘而不能直接除，那么我们要怎么实现除法呢？

答案是使用逆元。

## 2.4 逆元与费马小定理
在这里一个数$a$的逆元的定义是满足$ax\equiv 1\pmod m$的数$x$，存在逆元的充要条件是$\gcd(a,m)=1$，即$a$和$m$的最大公约数(greatest common factor)为1，即$a$和$m$互质\
如果两者不互质的话，例如求$2$在$6$下的逆元，你从$0$试到$5$可以发现都是不对的。

我们考虑我们要进行的运算相当于求$x\equiv ab^{-1}\pmod p$，也就是求出$bb^{-1}\equiv 1\pmod p$的$b^{-1}$即可。\
许多题目要求输出模意义下的答案只是为了防止精度损失和输出大数，因此为了保证每个数都有逆元，通常采用对大质数$p$取模，这样可以保证对除了$0$外的每个数都存在逆元。\
那么这要怎么求呢？\
我们可以考虑费马小定理！
> $a^{p-1}\equiv 1\pmod p,\text{p is prime and }p\not| a$

也就是说$a\cdot a^{p-2}\equiv 1\pmod p$即$a^{-1}\equiv a^{p-2}\pmod p$\
费马小定理的证明方法多种多样，这里不展开来讲了，大家只需要记住即可。

一般的质数大部分会取$1e9+7$或$998244353$，如果要求某个数$a$的逆元的话，我们就要计算$a^{1e9+5}$或$a^{998244351}$，如果直接暴力求解的话会直接TLE掉，因此我们要介绍一种可以在$O(\log b)$时间复杂度内求$a^b$的算法，快速幂！

## 2.5 快速幂
我们运用分治的思想，如果我们要求$a^b$的话，我们可以将其变为
$$
a^b =
\begin{cases}
\left(a^{\frac{b}{2}}\right)^2, & b = 2k, \\
\left(a^{\frac{b-1}{2}}\right)^2 \cdot a, & b = 2k+1.
\end{cases}
$$
也就是说我们可以写成下面的递归代码：
```c++
ll q_pow(ll base,ll p){
   if(p==0)return 1;
   ll tmp=q_pow(base,p/2);
   return tmp*tmp*(p&1?base:1);
}
```
但实际上我见到的大部分人都是采用另一种写法，也就是迭代写法：\
如果我们将b进行二进制分解，也就是$b=(c_tc_{t-1}c_{t-2}...c_1c_0)$的话\
我们可以发现$b=c_t2^t+c_{t-1}2^{t-1}+...+c_12^1+c_02^0$\
那么$a^b=a^{c_02^0}\times a^{c_12^1}\times ...\times a^{c_t2^t}$
我们可以快速的求出$a^{2^t}$，然后根据$c_t$决定是否乘上答案，也就是如果$c_t=1$的话我们就在答案上乘上$a^{2^t}$，否则我们就乘上$a^0$也就是$1$，相当于不乘.
由此我们可以写出下面的迭代代码：
```c++
// 也有人喜欢用ksm
ll q_pow(ll base,ll p){
   ll ret=1;
   while(p){
      if(p&1)ret=ret*base;
      base=base*base;
      p>>=1;
   }
   return ret;
}
```
由此我们就实现了$O(\log b)$的时间复杂度求$a^b$

那么我们就可以在上面的代码中加上对$mod$取模，然后写出下面的代码：
```c++
ll q_pow(ll base,ll p){
   ll ret=1;
   while(p){
      if(p&1)ret=ret*base%MOD;
      base=base*base%MOD;
      p>>=1;
   }
   return ret;
}
inline ll inv(ll x){
   return q_pow(x,MOD-2);
}
```

# 3. 质数
质数是因子只有$1$和它自身两个因子的数，而$1$不算是质数也不算是合数，而是单位元，而合数是除了1和质数外的数。

## 3.1 求解单个数是否是质数
我们要怎么确定单个数是否是质数呢？存在多种方法，但是在算法竞赛中我们一般使用试除法或$O(k\log n)$的素性测试，但是后者理论上比较难，大部分情况下我们还是使用前者，今天我们只讲试除法。


$O(\sqrt n)$的时间复杂度求$n$是否是质数，如果$n$不存在除了$1$和$n$外的因子的话，那么它就是质数。\
朴素的方法是$O(n)$的，但是我们考虑一个优化，即如果存在一个因子$x$的话，那么就存在$n=xy$，我们不妨令$x<=y$，那么可以确定如果$n$存在一个因子的话，那么一定存在一个不大于$\sqrt n$的因子，因此我们只需要检查小于等于$\sqrt n$中的所有数即可。
```c++
bool isPrime(int n){
   if(n==1)return 0;
   for(int i=2;i*i<=n;++i){
      if(n%i==0)return 0;
   }
   return 1;
}
```
我们可以发现，如果我们检查了$2$后发现$2$不是$n$的因子，那么可以确定的是所有$2$的倍数都不是$n$的因子，$3$,$5$等同理，因此我们可以只检查素因子，即只检查小于$\sqrt n$的质数，而在$[1,n]$的范围内大约有$\frac{n}{\ln n}$个质数，因此如果我们求出了$\sqrt n$内的所有质数再来判定的话可以将时间复杂度优化为$O(\frac{\sqrt n}{\ln n})$
```c++
bool isPrime(int n){
   for(int i=1;i<=cnt&&prime[i]*prime[i]<=n;++i){
      if(n%prime[i]==0)return 0;
   }
   return 1;
}
```

## 3.2 分解质因数
我们现在可以判定质数了，那么除了1和质数外就都是合数了，对于合数我们经常需要使用枚举它的因子和质因子，那么我们要怎么枚举它的因子和质因子呢？

### 3.2.1 枚举质因子
仔细查看检查朴素的检查一个数是否是质数的$O(\sqrt n)$算法，我们可以注意到一件事：\
- 如果$n$是质数，那么不存在任何因子，即不会存在任何一个因子$x$使得$n\%x=0$，它本身也不存在因子\
- 如果$n$不是质数，那么我们在枚举到一个因子$x$时，必然会先枚举到$x$的最小质因子$p$，因此我们可以写出下面的代码：

```c++
vector<int>getPrimeFactor(int n){
   vector<int>v;
   for(int i=2;i*i<=n;++i){
      while(n%i==0){
         v.push_back(i);
         n/=i;
      }
   }
   if(n!=1)v.push_back(n);
   return v;
}
```
而与优化判断单个数是否是质数一样，如果我们提前得知了在$O(\sqrt n)$内的所有质数，我们可以剔除掉所有要检查的合数，获得类似下面的代码：
```c++
vector<int>getPrimeFactor(int n){
   vector<int>v;
   for(int i=1;i<=cnt&&prime[i]*prime[i]<=n;++i){
      while(n%prime[i]==0){
         v.push_back(prime[i]);
         n/=prime[i];
      }
   }
   if(n!=1)v.push_back(n);
   return v;
}
```
### 3.2.2 枚举因子
我们考虑一下枚举一个数的因子要怎么做。\
首先考虑试除法，我们可以发现可以很简单的获取一个数的所有因子：
```c++
vector<int>getFactor(int n){
   vector<int>v;
   for(int i=1;i*i<=n;++i){
      if(n%i==0){
         v.push_back(i);
         if(i*i!=n){
            v.push_back(n/i);
         }
      }
   }
   return v;
}
```
大部分情况下我们也确实是这样求所有因子的.

但是实际上如果定义$d(n)$表示$n$的因子数量，$\omega(n)$表示$n$去重后的质因子数量的话，将$n$质因数分解，即$n=p_1^{k_1}p_2^{k_2}...p_{\omega(n)}^{k_{\omega(n)}}$\
那么我们可以试想一下对于$n$的因子要满足可以被$n$整除的条件，那么对于一个因子$x$，将它分解质因数后得到$x=p_1^{t_1}p_2^{t_2}...p_{\omega(n)}^{t_{\omega(n)}}$\
那么可以得到$t_1\leq k_1,t_2\leq k_2,...,t_{\omega(n)}\leq k_{\omega(n)}$，使用简单的组合分析可以发现$d(n)=\Pi_{i=1}^{\omega(n)}(k_i+1)$

简单分析后我们可以发现因子数量一定是$\leq 2\sqrt n$的，因此我们通过枚举第$i$个质因子选择几个同样可以得到所有的因子:
```c++
vector<pair<int,int>>primeFactor;
vector<int>getFactor(int n){
   vector<int>v;
   v.push_back(1);
   for(int i=0;i<primeFactor.size();++i){
      int p=primeFactor[i].first,e=primeFactor[i].second;
      int tmpSize=v.size(),tmp=p;
      for(int i2=1;i2<=e;++i2){
         for(int i3=0;i3<tmpSize;++i3){
            v.push_back(v[i3]*tmp);
         }
         tmp*=p;
      }
   }
   return v;
}
```
事实上查资料可以发现$d(n)\sim\frac{\sqrt n}{\ln n}$的，也就是说如果我们提前预处理出质数的话我们可以在$O(\frac{\sqrt n}{\ln n})$的时间复杂度内求出所有的因子的(不过我本人没怎么用过就是了)

# 4. 筛法
刚刚聊了这么多优化，很多优化都要先预处理出所有质数才能进行优化，但是如果对$[1,n]$内每一个数都进行素性测试的话需要的时间复杂度是$O(n\cdot \frac{\sqrt n}{\ln n})$

这样的时间复杂度无疑是得不偿失的，那么我们要怎么快速求出$[1,n]$内的所有质数呢？

答案就是使用筛法！
## 4.1 埃拉托斯特尼筛法(埃氏筛)
我们考虑这样一件事，考虑一个质数$p$，那这个质数的$k(k>1)$倍就全不是质数。
这就是埃氏筛的主要思想\
因此我们在筛$[1,n]$中的所有质数的时候我们可以从$2$开始的每一个质数$p$枚举每一个大于$p$的倍数，然后将其标记为合数，然后当我们枚举到一个没有被标记为合数的数时，这个数就是质数。\
埃氏筛的思想很简单，接下来我们计算一下时间复杂度：

考虑枚举每一个质数的倍数，那么时间复杂度就是$O(\sum_{i=1}^{\pi(n)}{\frac{n}{p_i}})$，简单分析一下调和级数也就是$\sum_{i=1}^{n}\frac{n}{i}\sim n\ln n$，考虑$[1,n]$中的质数数量$\pi(n)\sim \frac{n}{\ln n}$的，而刚刚我们得到的级数中的每一项都是小于同等项数的调和级数中的对应项的，因此我们的时间复杂度$O(n\sum_{i=1}^{\pi(n)}{\frac{1}{p_i}})<O(n\cdot \ln{\frac{n}{\ln n}})=O(n\ln n)$的。

但实际上它的时间复杂度数学证明是$O(n\log \log n)$的（具体我不会证）

下面是一种可能的实现：
```c++
int prime[N],vis[N],cnt;
void sieve(int n){
   for(int i=2;i<=n;++i){
      if(vis[i]==0){
         prime[++cnt]=i;
         for(ll i2=i*i;i2<=n;i2+=i){
            vis[i2]=1;
         }
      }
   }
}
```

```c++
int prime[N],vis[N],cnt;
void sieve(int n){
   for(int i=2;i<=n;++i){
      if(vis[i]==0){
         prime[++cnt]=i;
         for(ll i2=i*2;i2<=n;i2+=i){
            vis[i2]=1;
         }
      }
   }
}
```


## 4.2 欧拉筛(线性筛)
我们可以发现对于每一个合数，它都被筛去了其质因子数量$\omega(n)$次，我们能不能让其只被筛去一次呢？

答案是可以，我们可以使用线性筛来求，它的时间复杂度是严格$O(n)$的

其中的秘诀是，让每个合数都只被其最小的质因子筛去一次。\
我们先看代码：
```c++
int prime[N],vis[N],cnt;
void sieve(int n){
   for(int i=2;i<=n;++i){
      if(vis[i]==0){
         prime[++cnt]=i;
      }
      for(int i2=1;i2<=cnt&&i*prime[i2]<=n;++i2){
         vis[i*prime[i2]]=1;
         if(i%prime[i2]==0)break;
      }
   }
}
```
我们考虑一个数$30=2*3*5$，我们当枚举到$i=15$质数为$2$时，将$30$筛去，之后继续，那么就会变成$i=15$质数为$3$，而此时为$45=3*3*5$，然后可以发现$3|15$，因此退出，如果此时不退出我们就会枚举到$i=15$质数为$5$，而此时为$75=5*3*5$，而为了保证每个数都只被筛去一次，我们要将所有的数都由其最小的质数筛去，因此$75=5*3*5$我们要等枚举到$i=25$质数为$3$的时候将其筛去

也可以理解为我们筛到`i`的时候可以确定所有可能要被筛的数`i*k`的最小质因子一定不会大于`i`的最小质因子，而当`i%prime[i2]==0`时`prime[i2]`就是`i`的最小质因子，而在此之后的每个数`i*k`的最小质因子一定不是`prime[i2]`，因此我们要提前退出

因为欧拉筛保证了每个数都被严格的筛去了一次，因此也经常被用来求取数论函数。

# 5. gcd
gcd(greatest common divisor)是最大公因数，其经常在各类题目中出现。\
$\gcd (x,y)$的定义为满足$g|x$且$g|y$的最大$g$，对于单个数的gcd是它自身，对于多个数的gcd定义与两个数的类似。

我们如何求取gcd呢？
## 5.1 欧几里得算法
首先存在一个结论$\gcd(a,b)=\gcd(a,b\plusmn a)$，这是gcd的不变性，简单的证明如下：\
对于任意满足$d|a$且$d|b$的$d$，那么它也满足$d|a$且$d|(a-b)$；对于任意满足$d|a$且$d|(a-b)$的$d$，那么它也满足$d|a$且$d|b$，因此$a,b$的约数集合等于$a,a-b$的约数集合，其中最大的约数是两者的gcd，因此$\gcd(a,b)=\gcd(a,b\plusmn a)$

那么我们可以进一步得到下面的式子：\
$\gcd(a,b)=\gcd(a,b-a)=\gcd(a,b-2a)=...=\gcd(a,b\mod a)$\
并且显然存在$\gcd(a,b)=\gcd(b,a)$和$\gcd(a,a)=a$\
因此我们可以得到欧几里得算法：
```c++
int gcd(int a,int b){
   if(a==b)return a;
   return gcd(b,a%b);
}
```
同时我们定义$\gcd(a,0)=a$，因此我们可以写成下面的样子：
```c++
int gcd(int a,int b){
   return b==0?a:gcd(b,a%b);
}
```
迭代写法：
```c++
int gcd(int a,int b){
   while(b!=0){
      int r=a%b;
      a=b;
      b=r;
   }
   return a;
}
```
它的时间复杂度是$O(\log n)$的，因为每次都会让较大的数减少到小于较小的数的情况，而这个的最坏情况是取斐波那契数列的相邻两项，此时它需要项数次操作才能得出答案，而$fib_i$的增长是指数级别的，因此欧几里得算法的最坏情况是对数级别的，就是$O(\log n)$

## 5.2 最小公倍数
lcm(least common multiple)最小公倍数，与gcd差不多，但是是最小的满足$x|l,y|l$的$l$。\
可以通过$\operatorname{lcm}(a,b)=\frac{a\cdot b}{\gcd(a,b)}$来求得

# 6. 拓展

## 6.1 取模小tip
如果模运算中出现了减，一定要对应的加上一个`MOD`，例如
`a[i]=(b[i]-c[i]+MOD)%MOD`
因为这里可能会出现负数，导致后续计算中出现负数，此时如果再进行某些操作可能会出现问题，因此我们要给他填上一个`MOD`使得它一定是一个正数。\
同时我们要保证每出现一次减操作就添加一个`MOD`，例如：\
`a[i]=(b[i]-c[i]+MOD-d[i]+MOD)%MOD`\
如果出现了乘法，一定要在乘法后面添加上一个取模，保证每次进行运算的时候答案都是在$[0,MOD-1]$内的，其实只要保证运算后的答案不会爆掉即可。

## 6.2 筛法简单运用
考虑如果我们要求求出一个大小很大，但是区间长度较小的区间里的所有素数的话可以考虑分段进行：\
例如如果我们想要求出区间$[L,R]$，$1\leq L,R\leq 1e14,0\leq R-L\leq 1e7$的话，我们可以先线性筛筛出来$[1,\sqrt R]$即$[1,1e7]$里的所有质数，然后再用埃氏筛类似的思想将$[L,R]$里的所有合数筛掉，得到所有质数。

### 6.3 $O(n)$预处理求$[1,n]$内的每个数的质因子
我们考虑将每一个数的最小质因子`lp`给求出来，之后我们求一个数的所有质因子就可以一直跳跃求得一个数的所有质因子。
```c++
int prime[N],vis[N],cnt,lp[N];
void sieve(int n){
   for(int i=2;i<=n;++i){
      if(vis[i]==0){
         prime[++cnt]=i;
         lp[i]=i;
      }
      for(int i2=1;i2<=cnt&&i*prime[i2]<=n;++i2){
         vis[i*prime[i2]]=1;
         lp[i*prime[i2]]=prime[i2];
         if(i%prime[i2]==0){
            break;
         }
      }
   }
}
vector<int>getPrimeFactor(int n){
   vector<int>v;
   while(n!=1){
      v.push_back(lp[n]);
      n/=lp[n];
   }
   return v;
}

```

### 6.4 前缀gcd只有$\log n$个不同的gcd
如果考虑给定一个序列$A_n$，定义$f(x)=\gcd(a_1,a_2,...,a_x)$，那么$f(x)$最多只有$\log a$个不同的取值


