# java学习
## 异常处理
### Java的异常

一个健壮的程序必须可以处理各种各样的错误
方法一：约定返回错误码，常见于底层C函数
方法二：在语言上提供一个异常处理机制
Java内置了一套异常处理机制，总是使用异常来表示错误
异常是一种`class`，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：
```java
try{
	String s=processFile("C:\\test.txt");
	// ok
} catch(FileNotFoundException e){
	//File not found
} catch(SecurityException e){
	//no read permission
} catch(IOexception e){
	//io error
} catch(Exception e){
	//other error
}
```
Java中的异常是`class`，是有继承关系的
`Throwable`是异常体系的根，继承于`Object`。`Throwable`有两个体系：`Error`和`Exception`，`Error`表示严重的错误，程序一般无能为力，例如：
 - `OutOfMemoryError`：内存耗尽
 - `NoClassDefFoundError`：无法加载某个`class`
 - `StackOverflowError`：栈溢出

而`Exception`则是运行时的错误，它可以被捕获并处理
`Exception`又分为两大类：
1. `RuntimeException`及其子类
2. 非`RuntimeException`

Java规定：
 - 必须捕获的异常，包括`Exception`及其子类，但不包括`RuntimeException`及其子类，这种类型的异常被称为Checked Exception
 - 不需要捕获的异常，包括`Error`及其子类，和`RuntimeException`及其子类

**捕获异常**
使用`try...catch`语句，将可能发生异常的语句放在`try{...}`中，然后使用`catch(){}`捕获对应类型的`Exception`及其子类
如果不捕获必须捕获的异常会报编译失败的错误

在方法定义的时候，使用`throws Xxx`表示该方法可能抛出的异常类型。调用方在调用的过程中必须强制捕获这些异常，否则编译器会报错

只要是方法声明的Checked Exception，不在调用层捕获也必须要在更高层捕获，所有未捕获的异常，最终也必须在`main()`方法中捕获，不会出现漏写`try`的情况，这是由编译器保证的，`main()`方法也是最后的捕获`Exception`的机会
如果是测试代码，不想写任何`try`代码，就可以直接把`main()`方法定义为`throws Exception`：
```java
public class Main{
	public static void main(String args[])throws Exception{

	}
}
```
因为`main()`方法声明了可能抛出`Exception`，也就声明了可能抛出所有的`Exception`，因此内部就无需捕获了，代价就是一旦发生异常，程序就会立刻退出

捕获后不处理的方式是不好的，至少也要把异常记录下来：
```java
try{
	//
}catch(Exception e){
	e.printStackTrace();
}
```
所有异常都可以调用`printStackTrace()`方法打印异常栈

### 捕获异常

**多个catch**
捕获异常时可以使用多个`catch`语句，每个`catch`语句分别捕获对应的`Exception`及其子类，JVM在捕获到异常后会从上到下依次匹配`catch`语句，匹配到某个`catch`语句后便**不在**继续
存在多个`catch`时`catch`的顺序很重要：子类必须写在前面

**finally语句**
无论异常是否发生，都希望执行一些语句，我们可以在最后加一句`finally`，该语句保证无论有无错误都会执行
`finally`是保证一些语句必须执行的

**捕获多种异常**
可以使用`|`将一些类似但是不存在继承关系的语句合并：
```java
try{
	//
}catch(IOException|NumberFormatException){
	//
}
```

### 抛出异常


