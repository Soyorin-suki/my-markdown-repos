# 汇编语言程序格式

## 汇编语言程序的建立及汇编过程

`编辑源程序`->`MyFile.ASM`->`编译`->`MyFile.CRF`, `MyFile.LST`, `MyFile.OBJ`
`MyFile.OBJ`+`Other.OBJ`->`连接`->`MyFile.MAP`+`MyFile.EXE`

`MyFile.LST`是列表文件，是源代码+地址+机器码的对照表

类似这样：
```
0000 BB 01 00 	MOV AX, 1H
0003 CD 21		INT 21H
```
不参与后续生成exe

`MyFile.CRF`是交叉引用表(Cross Reference)，是符号表索引文件

是辅助文件

## 汇编语言程序的组成
- 汇编指令
  - 存在对应的机器码，可以被编译为机器指令，最终为所CPU执行
- 伪操作（伪指令）
  - 在源程序编译过程中由编译器完成的操作，可以完成如处理器选择、定义程序模式、定义数据、分配存储区、指示程序结果、宏指令等结果。

## 段定义: SEGMENT...ENDS
- SEGMENT和ENDS是一对成对使用的伪操作，用来定义在源程序中定义一个段，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪操作
  - SEGMENT声明一个段的开始
  - ENDS声明一个段的结束
- 一个段必须有一个名称来标识，使用格式为：
```assembly
NAME SEGMENT
...
NAME ENDS
```

## 寄存器与段的关联: ASSUME
- ASSUME: 声明某一段寄存器与程序中的某一个用SEGMENT...ENDS定义的段相关联
```assembly
ASSUME CS:codeseg, DS:dataseg
```

## 程序结束伪指令: END
- END是一个程序结束的结束标记，编译器在编译过程中，如果碰到了伪指令END，就结束对程序的编译
- 注意：END与ENDS不同


## 示例
```assembly
ASSUME CS:codeSeg 	;段寄存器声明
codeSeg SEGMENT 	;段开始
START:	MOV AX,0123H 	;start是标签(label)，类似main
		MOV BX,0456H
		ADD AX,BX
		ADD AX,AX
		MOV AX,4C00H 	;这行和下面这行表示程序返回
		INT 21H
codeSeg ENDS 		;段结束
END 				;程序结束
```

## 存储模型与简化段定义伪操作
是编译器的高级语法糖
```ASM
.model small
.stack 100H
.data
	...
.code
	mov ax,@data
	mov ds,ax
	...
	mov 4C00H
	INT 21H
end
```

## 数据定义及存储器分配伪操作
- 伪操作：DB, DW, DD, DF, DQ, DT
- DB(define byte),分配一字节的大小
- DW(define word),分配一字的大小
- DD(define double word),分配4字节，常用于存放32为数据或存放"远指针"
- DF(define far pointer),分配6字节。
- DQ(define quadword),分配8字节
- DT(define ten bytes),分配10字节
```
DATA_BATE DB 10, 4, 10H 	;DATA_BATE是标签/变量名，相当于地址，后面按顺序分配内存并赋初值
DATA_WORD DW 100, 100H, -5 	;
DATA_DW DD 3*20, 0FFFDH 	;
```
在数据定义伪操作中，常量表达式在汇编时求值；若计算结果超出数据类型所能表示的范围，汇编器只保留低位，多余高位被截断而不报错。

```
MESSAGE1 DB 'HELLO',?
MESSAGE2 DB 'AB',?
MESSAGE3 DW 'AB',?
```
上面的代码相当于下面
```
ADDR+0 48H 'H'
ADDR+1 45H 'E'
ADDR+2 4CH 'L'
ADDR+3 4CH 'L'
ADDR+4 4FH 'O'
ADDR+5 ??H 未初始化
```
```
ADDR+0 41H 'A'
ADDR+1 42H 'B'
ADDR+2 ??H
```
```
ADDR+0 42H 'B'
ADDR+1 41H 'A'	;将'AB'拼成了一个字，然后采用小端存储。
ADDR+2 ??H
ADDR+3 ??H
```
如果是`MESSGAE4 DW 'ABC',?`的话，会将'AB'拼成一个字，'C'单独拼成一个字，高位补0，?单独占一个字。

```
ARRAY DB 100 DUP(10)
	DB 2 DUP(0,2 DUP(1,2),3)
```
可以视为将10重复100次，之后再将(0,1,2,1,2,3)重复2次。

## 使用PTR操作符指定类型属性
```
OPER1 DB 1,2
OPER2 DW 1234H,5678H
...
	MOV AX, WORD PTR OPER1+1
	MOV AL, BYTE PTR OPER2
```

## 用LABEL操作符为同一地址指定不同类型属性的变量名
```
BYTE_ARRAY LABEL BYTE 	;在当前内存地址创建一个标签，在访问时按照BYTE访问
WORD_ARRAY DW 50 DUP(?) ;
BYTE_DATA LABEL BYTE 	;在当前内存地址创建一个标签，在访问时按照BYTE访问
WORD_DATA DW 100 		;
```

## 汇编语言程序中的语句格式
[名字] 操作助记符 操作数列表 [;注释]

- 名字
  - 字母，数字，专用字符:?.@-$
  - 除数字外，字符可以出现在名字的第一个位置。名字中如果用到"."，则必须是第一个字符
  - 用名字表示的**标号**和**变量**，都具有段值、偏移量、类型三种属性

表达式操作符
1. 算数操作符: +,-,*,/,MOD
2. 逻辑与位移操作符: AND, OR, XOR, NOT, SHL, SHR
3. 关系操作符: EQ, NE, LT, LE, GT, GE
4. 数据回送操作符: OFFSET, SEG, TYPE, LENGTH, SIZE
5. 属性操作符: PTR, 段操作符, SHORT, THIS, HIGH, LOW, HIGHWORD, LOWWORD


## 汇编语言程序开发的主要工具
1. 编辑程序：UltraEdit, Sublime, Edit...
2. 编译程序：MASM.EXE
3. 连接程序：LINK.EXE
4. 调试程序：DEBUG.EXE

## 在计算机上运行汇编语言程序的步骤
1. 编写：用编辑器建立ASM源文件
2. 编译：用MASM编译器把ASM文件转换为OBJ文件
3. 连接：用LINK连接器把OBJ文件转换为EXE文件
4. 执行：在DOS环境下直接键入文件名即可运行程序

## EXE文件是被谁执行的
- DOS中有一个程序command.com，这个程序在DOS中称为命令执行器，也就是DOS的shell;
- 在DOS中直接执行某个exe文件时，是正在运行的command将该exe文件中的程序加载入内存;
- command设置CPU的CS:IP指向程序的第一条指令（即程序的入口），从而使程序能够运行;
- 程序运行结束后，返回到command中，CPU继续运行command;

## EXE文件在内存中的加载
- 在内存中分配一段容量足够的内存区域，其起始地址为SA:0
- 在这段内存空间的前256个字节中，创建一个称为PSP的数据区，DOS利用该数据区和被加载的程序进行通信
- 从这段内存空间的第256字节处开始装入程序代码，程序的起始地址为SA+10H:0 注意：虽然PSP和程序区的物理地址连续，却有不同的段地址
- 将这段内存空间的段地址装入DS寄存器，并初始化其他相关寄存器后，设置CS:IP指向程序的入口

PSP: Program Sgement Prefix, 程序段前缀

## 汇编程序执行过程的跟踪
- 跟踪调试：在DOS环境下键入"debug 文件名"即可跟踪该程序的执行过程。
  - 用U命令查看内存中的程序指令；(Unassembly 反汇编)
  - 用T命令单步执行程序中的每一条指令，并观察每条指令的执行结果；(Trace into 单步进入)
  - 用P命令执行int 21;(Proceed/Trace over 单步跳过)
  - 执行后显示“Program terminated normally”，返回到debug中，表示程序正常结束 
  - 可以使用Q命令退出debug，返回到操作系统的command中


查看类指令：
- R的作用是查看/修改寄存器
- D的作用是查看内存内容
- U的作用是反汇编（将机器码变为汇编指令）

修改类指令：
- R可以修改寄存器
- E可以修改内存
- A可以将汇编指令写入内存

执行类命令：
- T单步跟踪，会进入子程序、`INT`
- P过程步进，不会进入子程序
- G连续进行，直到跑到断点或结束




DOS是disk operating system 磁盘操作系统，shell是命令解释器
