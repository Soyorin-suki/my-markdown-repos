# 寄存器与内存访问


## 80x86寄存器组
8086寄存器组分为"通用寄存器组","专用寄存器组"和"段寄存器组"三大类。
- 8086CPU共有14个寄存器。
- 所有寄存器都是16bit的，可以存放两个字节。
- AX,BX,CX,DX通常用来存放一般性数据，被称为数据寄存器。
  - AX: 累加器(Accumulator Register)
  - BX: 基址变址(Base Register)
  - CX: 计数器(Count Register)
  - DX: 数据(Data Register)

## 16bit寄存器的逻辑结构
- 一个16bit的寄存器可以存储一个16bit的数据
- 所能存储的数据的最大值是$2^{16}-1$
- 高8bit存放高位字节，低8bit存放低位字节

## 8bit寄存器兼容
- 8086上一代的8080是8bit架构的CPU
- 为了兼容8080，8086将AX,BX,CX,DX四个16bit寄存器的高8bit和低8bit分别命名为两个8bit寄存器
- AX -> AH(高8bit), AL(低8bit)
- BX -> BH, BL
- CX -> CH, CL
- DX -> DH, DL

例如如果AX的数据是4E20H，那么AH的值是4EH，AL的值是20H。

## 几条简单的汇编指令
| 汇编指令 | 控制CPU完成的动作 | 简略描述 |
| ---- | ---- | --- |
|MOV AX, 18|将18送入AX|AX=18|
|MOV AH, 78|将78送入AH|AH=78|
|ADD AX, 8|将寄存器AX的内容加8|AX=AX+8|
|MOV BX, AX|将寄存器AX的内容送入寄存器BX|BX=AX|
|INC CX|寄存器CX的内容加1|CX=CX+1|
|DEC DX|寄存器DX的内容减1|DX=DX-1|
|SUB BX, 5|寄存器BX的内容减5|BX=BX-5|

如果数字后面没有加H后缀，则表示是十进制，否则表示十六进制。

**指令中的操作对象的位数应一致**

## PPT上的小问题
使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方
```assembly
MOV AX, 1
ADD AX, AX
ADD AX, AX
ADD AX, AX
```	

## 字在内存中的存储
- 内存单元是字节(8bit)单元，以字节为单位顺序编址
- 一个字(16bit)要用两个连续的内存单元存放
- 低位字节存放在低地址单元，高位字节存放在高地址单元（小端模式）

|||
|-----|-----|
|0|20H|
|1|4EH|
|2|12H|
|3|00H|
|...|...|

- 0地址单元存储的**字节型**数据是20H
- 0地址单元存储的**字型**数据是4E20H
- 2地址单元存储的**字节型**数据是12H
- 2地址单元存储的**字型**数据是0012H
- 1地址单元存储的**字型**数据是124EH


## 字在内存中的存储
- 字单元：即存放一个字型数据(16bit)所需的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放高位字节，低地址内存单元中存放低位字节。
- 我们将起始地址为N的字单元简称为N地址字单元。

## DS寄存器
- CPU要读取一个内存单元的时候，必须知道该内存单元的地址。
- 内存物理地址=段地址: 偏移地址
- 8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址

## 如何读取一个地址？
- 10000H=1000H:0H
- [偏移地址]表示读取一个内存单元中的数据
- 8086CPU自动取DS寄存器的内容作为段地址，加上偏移地址，得到内存单元的物理地址，然后访问该内存单元，读取数据到寄存器中。
- 8086CPU不支持将数据直接送入段寄存器
```assembly
MOV BX, 10000H
MOV DS, BX
MOV AL, [0]
```

将寄存器中的数据送入内存单元与之类似：
```assembly
MOV BX, 2000H
MOV DS, BX
MOV [5], AL
```

## 字的传送
- 8086CPU可以一次传送一个字(16bit)的数据
- 传送字时，必须使用字单元的起始地址作为偏移
```assembly
MOV BX, 3000H
MOV DS, BX
MOV AX, [0]   ; 将3000H和3001H两个内存单元中的数据送入AX
MOV [2], AX   ; 将AX中的数据送入3002H和3003H两个内存单元
```

## 数据段
- 数据段是用来存放程序运行时所需的数据的内存区域。
- 对于8086PC机，我们可以根据需要将一组内存单元定义为一个段
- 可以将一组长度为N(N<=64K)、地址连续、起始地址为16的倍数的内存单元当做专门储存数据的内存空间，从而定义了一个数据段
- 例如我们采用123B0H~123B9H这段空间存放数据
  - 段地址: 123BH
  - 长度: 10H(16个字节)

## 访问数据段中的数据
- 将123B0H~123B9H的内存单元定义为数据段后，编写指令序列累加这个数据段中的前三个单元中的数据：
```assembly
MOV AX, 123BH
MOV DS, AX
MOV AL, [0]
ADD AL, [1]
ADD AL, [2]
```
- 将123B0H~123BAH的内存单元定义为数据段后，编写指令序列累加这个数据段中的前三个字单元中的数据：
```assembly
MOV AX, 123BH
MOV DS, AX
MOV AX, [0]
ADD AX, [2]
ADD AX, [4]
```

## MOV指令的格式
合法的MOV指令格式有以下几种：
- MOV 寄存器, 数据/寄存器/内存单元/段寄存器
- MOV 内存单元, 寄存器/数据
- MOV 段寄存器, 寄存器/内存单元

## ADD指令与SUB指令的格式
合法的ADD指令和SUB指令格式有以下几种：
- ADD 寄存器, 数据/寄存器/内存单元
- ADD 内存单元, 寄存器/数据
- SUB 寄存器, 数据/寄存器/内存单元
- SUB 内存单元, 寄存器/数据

对于段寄存器不允许进行加减操作。只能通过MOV指令将数据送入段寄存器。

## 课后练习
(省略)

数据和程序有区别吗？如何确定内存中的信息哪些是数据，哪些是程序？
- 物理上没有本质区别。内存只是存放二进制位，CPU只是按`CS:IP`指向的位置把字节解释为指令并执行，把其他位置解释为数据并读/写。换言之，同一段内存的某些字节可以被当做程序执行，也可以被当做数据读取(这就是自修改代码的原理)
- 如何区分(语义上/由上下文决定)
  - 由执行流决定：CPU执行指令时，`CS:IP`指向的内存单元被解释为指令，其它内存单元被解释为数据
  - 由程序/编译器/链接器决定：通常程序将代码放到`.text`/代码段，数据放到`.data`/`.bss`段，链接器/加载器也会按此加载，但这是约定，不是物理上的区别
  - 现代保护机制：现在的CPU/操作系统有"可执行/不可执行(NX)"标志和内存分页，能将数据页标记为不可执行，从而防止将数据当成程序执行：这是"可执行位"的安全用途。但在8086实模式下没有这些保护。

