# 栈与寄存器

## 内存中的栈
- CPU都支持对内存中栈的使用，提供了相关的指令以栈的方式访问内存空间。
- 8086CPU的入栈和出栈都是以字为单位进行的。
- 入栈指令: PUSH
  - PUSH AX;将寄存器AX的内容入栈
- 出栈指令: POP
  - POP BX;将栈顶的内容出栈到寄存器BX

## 两个疑问
- CPU如何知道哪段内存空间被当做栈来使用？
- CPU如何知道栈顶的位置在哪里？

## SS:SP
- 段寄存器SS: 存放栈段的段地址
- 指针寄存器SP: 存放栈顶的偏移地址
- SS:SP: 指向栈顶元素

## PUSH AX 的完整执行过程
1. SP=SP-2，SS:SP 指向栈顶前面的单元，依次作为新的栈顶；
2. 将AX寄存器的内容存放到 SS:SP 所指向的内存单元中。

这只是一种理解，但实际上`PUSH AX`与`SUB SP,2`后`MOV [SS:SP],AX`并不完全等价。

注意栈是向低地址方向增长的。

## POP AX 的完整执行过程
1. 将 SS:SP 所指向的内存单元中的内容送入 AX 寄存器；
2. SP=SP+2，SS:SP 指向栈顶下一个单元，作为新的栈顶。

## 关于PUSH, POP指令的注意事项
- 出栈后，SS:SP指向新的栈顶1000EH，POP操作前的栈顶元素，1000CH处的2266H依然存在，但是，它已经不在栈中。
- 当再次执行PUSH指令时，SS:SP移动至1000CH处，并在里面写入新的数据，它将会被覆盖。
- PUSH和POP等栈操作指令，修改的只是SP，即栈顶的变化范围，最大为0H~FFFFH。
- PUSH、POP指令不同于MOV指令，CPU执行MOV指令值只需要一步操作，即数据传送，但是执行PUSH、POP需要两部操作

## 问题分析一
- 如果将10000H~1000FH这段空间当做栈，初始状态栈是空的，此时SS=1000H，SP=0010H。

## 问题分析二
- 如果将10000H~1FFFFH这段空间当做栈，初始状态栈是空的，此时SS=1000H,SP=0000H。

## 栈顶越界
- 当栈满的时候再使用PUSH指令入栈
- 当栈空的时候再使用POP指令出栈
- 栈顶越界将覆盖栈空间之外的内存单元的数据、代码等，将引发一系列的错误，破坏程序的正常运行（可能是自己的程序、也可能是别的程序）

8086CPU无法保证栈顶不会越界
- 8086CPU只知道当前栈顶在何处，不知道栈空间有多大。

## PUSH和POP指令的格式
- PUSH 寄存器/段寄存器/内存单元
- POP 寄存器/段寄存器/内存单元

## 程序样例一
将10000H~1000FH这段空间作为栈，初始状态是空的，将AX,BX,DS中的数据入栈。
```assembly
MOV AX, 1000H
MOV SS, AX
MOV SP, 0010H
PUSH AX
PUSH BX
PUSH DS
```

## 程序样例二
将10000H~1000FH这段空间作为栈，初始状态是空的；\
设置AX=001AH, BX=001BH;\
将AX,BX中的数据入栈；\
然后将AX,BX清零；\
从栈中恢复AX,BX的数据.
```assembly
MOV AX, 1000H
MOV SS, AX
MOV SP, 0010H
MOV AX, 001AH
MOV BX, 001BH
PUSH AX
PUSH BX
SUB AX, AX
SUB BX, BX
POP BX
POP AX
```

## 程序样例三
将10000H~1000FH这段空间作为栈，初始状态是空的；\
设置AX=002AH, BX=002BH; \
利用栈，交换AX与BX的数据
```assembly
MOV AX=1000H
MOV SS, AX
MOV SP, 0010H
MOV AX, 002AH
MOV BX, 002BH
PUSH AX
PUSH BX
POP AX
POP BX
```

## 程序样例四
完成前三行代码使其可以在10000H处写入2266H
```assembly
MOV AX, 1000H
MOV SS, AX
MOV SP, 2
MOV AX, 2266H
PUSH AX
```

